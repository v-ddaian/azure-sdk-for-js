/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as coreClient from "@azure/core-client";

export type GeoJsonObjectUnion =
  | GeoJsonObject
  | GeoJsonGeometryUnion
  | GeoJsonFeature
  | GeoJsonFeatureCollection;
export type GeoJsonGeometryUnion =
  | GeoJsonGeometry
  | GeoJsonMultiPoint
  | GeoJsonMultiPolygon
  | GeoJsonPoint
  | GeoJsonLineString
  | GeoJsonMultiLineString
  | GeoJsonPolygon
  | GeoJsonGeometryCollection;

/** An object with a matrix of coordinates. */
export interface PostRouteMatrixRequestBody {
  /** A valid `GeoJSON MultiPoint` geometry type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1.3) for details. */
  origins?: GeoJsonMultiPoint;
  /** A valid `GeoJSON MultiPoint` geometry type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1.3) for details. */
  destinations?: GeoJsonMultiPoint;
}

/** A valid `GeoJSON` object. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3) for details. */
export interface GeoJsonObject {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  type:
    | "GeoJsonGeometry"
    | "MultiPoint"
    | "MultiPolygon"
    | "Point"
    | "LineString"
    | "MultiLineString"
    | "Polygon"
    | "GeometryCollection"
    | "Feature"
    | "FeatureCollection";
}

/** Data contained by a `GeoJson MultiPoint`. */
export interface GeoJsonMultiPointData {
  /** Coordinates for the `GeoJson MultiPoint` geometry. */
  coordinates: number[][];
}

/** This object is returned from a successful Route Matrix call. For ex, if 2 origins and 3 destinations are provided, there are going to 2 arrays with 3 elements in each. Each element's content depends on the options provided in the query. */
export interface RouteMatrixResponse {
  /**
   * Format Version property
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly formatVersion?: string;
  /**
   * Results as a 2 dimensional array of route summaries.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly matrix?: RouteMatrixResult[][];
  /**
   * Summary object
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly summary?: RouteMatrixSummary;
}

/** Matrix result object */
export interface RouteMatrixResult {
  /**
   * StatusCode property for the current cell in the input matrix.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly statusCode?: number;
  /**
   * Response object of the current cell in the input matrix.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly response?: RouteMatrixResultResponse;
}

/** Response object of the current cell in the input matrix. */
export interface RouteMatrixResultResponse {
  /**
   * Summary object for route section.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly routeSummary?: RouteResultLegSummary;
}

/** Summary object for route section. */
export interface RouteResultLegSummary {
  /**
   * Length In Meters property
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly lengthInMeters?: number;
  /**
   * Estimated travel time in seconds property that includes the delay due to real-time traffic. Note that even when traffic=false travelTimeInSeconds still includes the delay due to traffic. If DepartAt is in the future, travel time is calculated using time-dependent historic traffic data.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly travelTimeInSeconds?: number;
  /**
   * Estimated delay in seconds caused by the real-time incident(s) according to traffic information. For routes planned with departure time in the future, delays is always 0. To return additional travel times using different types of traffic information, parameter computeTravelTimeFor=all needs to be added.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly trafficDelayInSeconds?: number;
  /**
   * Departure Time property
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly departureTime?: string;
  /**
   * Arrival Time property
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly arrivalTime?: string;
  /**
   * Estimated travel time calculated as if there are no delays on the route due to traffic conditions (e.g. congestion). Included only if computeTravelTimeFor = all is used in the query.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly noTrafficTravelTimeInSeconds?: number;
  /**
   * Estimated travel time calculated using time-dependent historic traffic data. Included only if computeTravelTimeFor = all is used in the query.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly historicTrafficTravelTimeInSeconds?: number;
  /**
   * Estimated travel time calculated using real-time speed data. Included only if computeTravelTimeFor = all is used in the query.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly liveTrafficIncidentsTravelTimeInSeconds?: number;
  /**
   * Estimated fuel consumption in liters using the Combustion Consumption Model. Included if vehicleEngineType is set to _combustion_ and constantSpeedConsumptionInLitersPerHundredkm is specified. The value will be non-negative.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly fuelConsumptionInLiters?: number;
  /**
   * Estimated electric energy consumption in kilowatt hours (kWh) using the Electric Consumption Model. Included if vehicleEngineType is set to electric and constantSpeedConsumptionInkWhPerHundredkm is specified. The value of batteryConsumptionInkWh includes the recuperated electric energy and can therefore be negative (which indicates gaining energy). If both maxChargeInkWh and currentChargeInkWh are specified, recuperation will be capped to ensure that the battery charge level never exceeds maxChargeInkWh. If neither maxChargeInkWh nor currentChargeInkWh are specified, unconstrained recuperation is assumed in the consumption calculation.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly batteryConsumptionInkWh?: number;
}

/** Summary object */
export interface RouteMatrixSummary {
  /**
   * Number of successful routes in the response.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly successfulRoutes?: number;
  /**
   * Total number of routes requested. Number of cells in the input matrix.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly totalRoutes?: number;
}

/** Common error response for all Azure Resource Manager APIs to return error details for failed operations. (This also follows the OData error response format.). */
export interface ErrorResponse {
  /** The error object. */
  error?: ErrorDetail;
}

/** The error detail. */
export interface ErrorDetail {
  /**
   * The error code.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly code?: string;
  /**
   * The error message.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly message?: string;
  /**
   * The error target.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly target?: string;
  /**
   * The error details.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly details?: ErrorDetail[];
  /**
   * The error additional info.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly additionalInfo?: ErrorAdditionalInfo[];
}

/** The resource management error additional info. */
export interface ErrorAdditionalInfo {
  /**
   * The additional info type.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly type?: string;
  /**
   * The additional info.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly info?: Record<string, unknown>;
}

/** This object is returned from a successful Route Directions call */
export interface RouteDirectionsResponse {
  /**
   * Format Version property
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly formatVersion?: string;
  /**
   * Routes array
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly routes?: RouteDirectionsResult[];
  /**
   * Optimized sequence of waypoints. It shows the index from the user provided waypoint sequence for the original and optimized list. For instance, a response:
   *
   * ```
   * <optimizedWaypoints>
   * <waypoint providedIndex="0" optimizedIndex="1"/>
   * <waypoint providedIndex="1" optimizedIndex="2"/>
   * <waypoint providedIndex="2" optimizedIndex="0"/>
   * </optimizedWaypoints>
   * ```
   *
   * means that the original sequence is [0, 1, 2] and optimized sequence is [1, 2, 0]. Since the index starts by 0 the original is "first, second, third" while the optimized is "second, third, first".
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly optimizedWaypoints?: RouteOptimizedWaypoint[];
  /** Reports the effective settings used in the current call. */
  report?: RouteResponseReport;
}

export interface RouteDirectionsResult {
  /**
   * Summary object
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly summary?: RouteDirectionsSummary;
  /**
   * Legs array
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly legs?: RouteResultLeg[];
  /**
   * Sections array
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly sections?: RouteResultSection[];
  /**
   * Contains guidance related elements. This field is present only when guidance was requested and is available.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly guidance?: RouteResultGuidance;
}

/** Summary object */
export interface RouteDirectionsSummary {
  /**
   * Length In Meters property
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly lengthInMeters?: number;
  /**
   * Estimated travel time in seconds property that includes the delay due to real-time traffic. Note that even when traffic=false travelTimeInSeconds still includes the delay due to traffic. If DepartAt is in the future, travel time is calculated using time-dependent historic traffic data.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly travelTimeInSeconds?: number;
  /**
   * Estimated delay in seconds caused by the real-time incident(s) according to traffic information. For routes planned with departure time in the future, delays is always 0. To return additional travel times using different types of traffic information, parameter computeTravelTimeFor=all needs to be added.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly trafficDelayInSeconds?: number;
  /**
   * Departure Time property
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly departureTime?: string;
  /**
   * Arrival Time property
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly arrivalTime?: string;
}

export interface RouteResultLeg {
  /**
   * Summary object for route section.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly summary?: RouteResultLegSummary;
  /**
   * Points array
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly points?: CoordinatesPair[];
}

/** A location represented as a latitude and longitude. */
export interface CoordinatesPair {
  /** Latitude property */
  latitude?: number;
  /** Longitude property */
  longitude?: number;
}

export interface RouteResultSection {
  /**
   * Start Point Index property
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly startPointIndex?: number;
  /**
   * End Point Index property
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly endPointIndex?: number;
  /**
   * Section Type property
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly sectionType?: string;
  /**
   * Travel Mode property
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly travelMode?: string;
  /**
   * Type of the incident. Can currently be JAM, ROAD_WORK, ROAD_CLOSURE, or OTHER. See "tec" for detailed information.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly simpleCategory?: string;
  /**
   * Effective speed of the incident in km/h, averaged over its entire length.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly effectiveSpeedInKmh?: number;
  /**
   * Delay in seconds caused by the incident.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly delayInSeconds?: number;
  /**
   * The magnitude of delay caused by the incident. These values correspond to the values of the response field ty of the [Get Traffic Incident Detail API](https://docs.microsoft.com/rest/api/maps/traffic/gettrafficincidentdetail).
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly magnitudeOfDelay?: MagnitudeOfDelay;
  /** Details of the traffic event, using definitions in the [TPEG2-TEC](https://www.iso.org/standard/63116.html) standard. Can contain effectCode and causes elements. */
  tec?: RouteResultSectionTec;
}

/** Details of the traffic event, using definitions in the [TPEG2-TEC](https://www.iso.org/standard/63116.html) standard. Can contain effectCode and causes elements. */
export interface RouteResultSectionTec {
  /**
   * The effect on the traffic flow. Contains a value in the tec001:EffectCode table, as defined in the [TPEG2-TEC](https://www.iso.org/standard/63116.html) standard. Can be used to color-code traffic events according to severity.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly effectCode?: number;
  /** Causes array */
  causes?: RouteResultSectionTecCause[];
}

/** The cause of the traffic event. Can contain mainCauseCode and subCauseCode elements. Can be used to define iconography and descriptions. */
export interface RouteResultSectionTecCause {
  /**
   * The main cause of the traffic event. Contains a value in the tec002:CauseCode table, as defined in the [TPEG2-TEC](https://www.iso.org/standard/63116.html) standard.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly mainCauseCode?: number;
  /**
   * The subcause of the traffic event. Contains a value in the sub cause table defined by the mainCauseCode, as defined in the [TPEG2-TEC](https://www.iso.org/standard/63116.html) standard.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly subCauseCode?: number;
}

/** Contains guidance related elements. This field is present only when guidance was requested and is available. */
export interface RouteResultGuidance {
  /**
   * A list of instructions describing maneuvers.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly instructions?: RouteResultInstruction[];
  /**
   * Groups a sequence of instruction elements which are related to each other.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly instructionGroups?: RouteResultInstructionGroup[];
}

/** A set of attributes describing a maneuver, e.g. 'Turn right', 'Keep left', 'Take the ferry', 'Take the motorway', 'Arrive'. */
export interface RouteResultInstruction {
  /**
   * Distance from the start of the route to the point of the instruction.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly routeOffsetInMeters?: number;
  /**
   * Estimated travel time up to the point corresponding to routeOffsetInMeters.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly travelTimeInSeconds?: number;
  /** A location represented as a latitude and longitude. */
  point?: CoordinatesPair;
  /**
   * The index of the point in the list of polyline "points" corresponding to the point of the instruction.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly pointIndex?: number;
  /** Type of the instruction, e.g., turn or change of road form. */
  instructionType?: GuidanceInstructionType;
  /**
   * The road number(s) of the next significant road segment(s) after the maneuver, or of the road(s) to be followed. Example: ["E34", "N205"]
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly roadNumbers?: string[];
  /**
   * The number(s) of a highway exit taken by the current maneuver. If an exit has multiple exit numbers, they will be separated by "," and possibly aggregated by "-", e.g., "10, 13-15".
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly exitNumber?: string;
  /**
   * Street name of the next significant road segment after the maneuver, or of the street that should be followed.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly street?: string;
  /**
   * The text on a signpost which is most relevant to the maneuver, or to the direction that should be followed.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly signpostText?: string;
  /**
   * 3-character [ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-3 country code. E.g. USA.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly countryCode?: string;
  /**
   * A subdivision (e.g., state) of the country, represented by the second part of an [ISO 3166-2](https://www.iso.org/standard/63546.html) code. This is only available for some countries like the US, Canada, and Mexico.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly stateCode?: string;
  /**
   * The type of the junction where the maneuver takes place. For larger roundabouts, two separate instructions are generated for entering and leaving the roundabout.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly junctionType?: JunctionType;
  /**
   * Indicates the direction of an instruction. If junctionType indicates a turn instruction:
   *
   *   * 180 = U-turn
   *   * [-179, -1] = Left turn
   *   * 0 = Straight on (a '0 degree' turn)
   *   * [1, 179] = Right turn
   *
   * If junctionType indicates a bifurcation instruction:
   *
   *   * <0 - keep left
   *   * \>0 - keep right
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly turnAngleInDecimalDegrees?: number;
  /**
   * This indicates which exit to take at a roundabout.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly roundaboutExitNumber?: string;
  /**
   * It is possible to optionally combine the instruction with the next one. This can be used to build messages like "Turn left and then turn right".
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly possibleCombineWithNext?: boolean;
  /**
   * Indicates left-hand vs. right-hand side driving at the point of the maneuver.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly drivingSide?: DrivingSide;
  /**
   * A code identifying the maneuver.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly maneuver?: GuidanceManeuver;
  /**
   * A human-readable message for the maneuver.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly message?: string;
  /**
   * A human-readable message for the maneuver combined with the message from the next instruction. Sometimes it is possible to combine two successive instructions into a single instruction making it easier to follow. When this is the case the possibleCombineWithNext flag will be true. For example:
   *
   * ```
   * 10. Turn left onto Einsteinweg/A10/E22 towards Ring Amsterdam
   * 11. Follow Einsteinweg/A10/E22 towards Ring Amsterdam
   * ```
   *
   * The possibleCombineWithNext flag on instruction 10 is true. This indicates to the clients of coded guidance that it can be combined with instruction 11. The instructions will be combined automatically for clients requesting human-readable guidance. The combinedMessage field contains the combined message:
   *
   * ```
   * Turn left onto Einsteinweg/A10/E22 towards Ring Amsterdam
   * then follow Einsteinweg/A10/E22 towards Ring Amsterdam.
   * ```
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly combinedMessage?: string;
}

/** Groups a sequence of instruction elements which are related to each other. The sequence range is constrained with firstInstructionIndex and lastInstructionIndex. When human-readable text messages are requested for guidance (instructionType=text or tagged), then the instructionGroup has a summary message returned when available. */
export interface RouteResultInstructionGroup {
  /**
   * Index of the first instruction.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly firstInstructionIndex?: number;
  /**
   * Index of the last instruction.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly lastInstructionIndex?: number;
  /**
   * Length of the group.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly groupLengthInMeters?: number;
  /**
   * Summary message when human-readable text messages are requested for guidance (instructionType=text or tagged).
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly groupMessage?: string;
}

/** Optimized way point object. */
export interface RouteOptimizedWaypoint {
  /**
   * Way point index provided by the user.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly providedIndex?: number;
  /**
   * Optimized way point index from the system.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly optimizedIndex?: number;
}

/** Reports the effective settings used in the current call. */
export interface RouteResponseReport {
  /**
   * Effective parameters or data used when calling this Route API.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly effectiveSettings?: RouteResponseReportEffectiveSetting[];
}

/** Effective parameter or data used when calling this Route API. */
export interface RouteResponseReportEffectiveSetting {
  /**
   * Name of the parameter used.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly key?: string;
  /**
   * Value of the parameter used.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly value?: string;
}

/** Post body parameters for Route directions. */
export interface PostRouteDirectionsRequestBody {
  /**
   * A GeoJSON Geometry collection representing sequence of coordinates used as input for route reconstruction and for calculating zero or more alternative routes to this reference route.
   *   - The provided sequence of supporting points is used as input for route reconstruction.
   *   - The alternative routes are calculated between the origin and destination points specified in the base path parameter locations.
   *   - If both _minDeviationDistance_ and _minDeviationTime_ are set to zero, then these origin and destination points are
   *   expected to be at (or very near) the beginning and end of the reference route, respectively.
   *   - Intermediate locations (_waypoints_) are not supported when using <_supportingPoints_>.
   *   - The reference route may contain traffic incidents of type _ROAD_CLOSURE_, which are
   *   ignored for the calculation of the reference route's travel time and traffic delay.
   */
  supportingPoints?: Record<string, unknown>;
  /** This is a list of 3-character, ISO 3166-1, alpha-3 country codes of countries in which all toll roads with vignettes are to be avoided, e.g. "AUS,CHE". Toll roads with vignettes in countries not in the list are unaffected. Note: It is an error to specify both **avoidVignette** and **allowVignette**. */
  avoidVignette?: string[];
  /** This is a list of 3-character, ISO 3166-1, alpha-3 country codes of countries in which toll roads with vignettes are allowed, e.g. "AUS,CHE". Specifying **allowVignette** with some countries X is equivalent to specifying **avoidVignette** with all countries but X. Specifying **allowVignette** with an empty list is the same as avoiding all toll roads with vignettes. Note: It is an error to specify both **avoidVignette** and **allowVignette**. */
  allowVignette?: string[];
  /** A GeoJSON MultiPolygon representing list of areas to avoid. Only rectangle polygons are supported. The maximum size of a rectangle is about 160x160 km. Maximum number of avoided areas is **10**. It cannot cross the 180th meridian. It must be between -80 and +80 degrees of latitude. */
  avoidAreas?: GeoJsonMultiPolygon;
}

export interface GeoJsonMultiPolygonData {
  /** Contains a list of valid `GeoJSON Polygon` objects. **Note** that coordinates in GeoJSON are in x, y order (longitude, latitude). */
  coordinates: number[][][][];
}

/** This object is returned from a successful Route Reachable Range call */
export interface GetRouteRangeResponse {
  /**
   * Format Version property
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly formatVersion?: string;
  /** Reachable Range */
  reachableRange?: RouteRange;
  /** Reports the effective settings used in the current call. */
  report?: RouteResponseReport;
}

/** Reachable Range */
export interface RouteRange {
  /** Center point of the reachable range */
  center?: CoordinatesPair;
  /**
   * Polygon boundary of the reachable range represented as a list of points.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly boundary?: CoordinatesPair[];
}

/** This type represents the request body for the Batch service. */
export interface BatchRequestBody {
  /** The list of queries to process. */
  batchItems?: BatchRequestBodyBatchItemsItem[];
}

/** Batch Query object */
export interface BatchRequestBodyBatchItemsItem {
  /** Partial query string. */
  query?: string;
}

/** This object is returned from a successful Batch service call. Extend with 'batchItems' property. */
export interface BatchResponse {
  /**
   * Summary for the batch request
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly summary?: BatchResponseSummary;
}

/** Summary for the batch request */
export interface BatchResponseSummary {
  /**
   * Number of successful requests in the batch
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly successfulRequests?: number;
  /**
   * Total number of requests in the batch
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly totalRequests?: number;
}

/** An item returned from Batch API. Extend with 'response' property. */
export interface BatchItem {
  /**
   * HTTP request status code.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly statusCode?: number;
}

/** Data contained by a `GeoJson Point`. */
export interface GeoJsonPointData {
  /** A `Position` is an array of numbers with two or more elements. The first two elements are _longitude_ and _latitude_, precisely in that order. _Altitude/Elevation_ is an optional third element. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1.1) for details. */
  coordinates: number[];
}

export interface GeoJsonLineStringData {
  /** Coordinates for the `GeoJson LineString` geometry. */
  coordinates: number[][];
}

export interface GeoJsonMultiLineStringData {
  /** Coordinates for the `GeoJson MultiLineString` geometry. */
  coordinates: number[][][];
}

export interface GeoJsonPolygonData {
  /** Coordinates for the `GeoJson Polygon` geometry type. */
  coordinates: number[][][];
}

export interface GeoJsonGeometryCollectionData {
  /** Contains a list of valid `GeoJSON` geometry objects. **Note** that coordinates in GeoJSON are in x, y order (longitude, latitude). */
  geometries: GeoJsonGeometryUnion[];
}

export interface GeoJsonFeatureData {
  /** A valid `GeoJSON` geometry object. The type must be one of the seven valid GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon and GeometryCollection. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1) for details. */
  geometry: GeoJsonGeometryUnion;
  /** Properties can contain any additional metadata about the `Feature`. Value can be any JSON object or a JSON null value */
  properties?: Record<string, unknown>;
  /** Identifier for the feature. */
  id?: string;
  /** The type of the feature. The value depends on the data model the current feature is part of. Some data models may have an empty value. */
  featureType?: string;
}

export interface GeoJsonFeatureCollectionData {
  /** Contains a list of valid `GeoJSON Feature` objects. */
  features: GeoJsonFeature[];
}

/** A valid `GeoJSON` geometry object. The type must be one of the seven valid GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon and GeometryCollection. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1) for details. */
export type GeoJsonGeometry = GeoJsonObject & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  type:
    | "GeoJsonGeometry"
    | "MultiPoint"
    | "MultiPolygon"
    | "Point"
    | "LineString"
    | "MultiLineString"
    | "Polygon"
    | "GeometryCollection";
};

/** A valid `GeoJSON Feature` object type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.2) for details. */
export type GeoJsonFeature = GeoJsonObject &
  GeoJsonFeatureData & {
    /** Polymorphic discriminator, which specifies the different types this object can be */
    type: "Feature";
  };

/** A valid `GeoJSON FeatureCollection` object type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.3) for details. */
export type GeoJsonFeatureCollection = GeoJsonObject &
  GeoJsonFeatureCollectionData & {
    /** Polymorphic discriminator, which specifies the different types this object can be */
    type: "FeatureCollection";
  };

/** A valid `GeoJSON MultiPoint` geometry type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1.3) for details. */
export type GeoJsonMultiPoint = GeoJsonGeometry & GeoJsonMultiPointData & {};

/** The result of the query. RouteDirectionsResponse if the query completed successfully, ErrorResponse otherwise. */
export type RouteDirectionsBatchItemResponse = RouteDirectionsResponse &
  ErrorResponse & {};

/** A valid `GeoJSON MultiPolygon` object type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1.7) for details. */
export type GeoJsonMultiPolygon = GeoJsonGeometry &
  GeoJsonMultiPolygonData & {};

/** This object is returned from a successful Route Directions Batch service call. */
export type RouteDirectionsBatchResponse = BatchResponse & {
  /**
   * Array containing the batch results.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly batchItems?: RouteDirectionsBatchItem[];
};

/** An item returned from Route Directions Batch service call. */
export type RouteDirectionsBatchItem = BatchItem & {
  /**
   * The result of the query. RouteDirectionsResponse if the query completed successfully, ErrorResponse otherwise.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly response?: RouteDirectionsBatchItemResponse;
};

/** A valid `GeoJSON Point` geometry type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1.2) for details. */
export type GeoJsonPoint = GeoJsonGeometry & GeoJsonPointData & {};

/** A valid `GeoJSON LineString` geometry type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1.4) for details. */
export type GeoJsonLineString = GeoJsonGeometry & GeoJsonLineStringData & {};

/** A valid `GeoJSON MultiLineString` geometry type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1.5) for details. */
export type GeoJsonMultiLineString = GeoJsonGeometry &
  GeoJsonMultiLineStringData & {};

/** A valid `GeoJSON Polygon` geometry type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1.6) for details. */
export type GeoJsonPolygon = GeoJsonGeometry & GeoJsonPolygonData & {};

/** A valid `GeoJSON GeometryCollection` object type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1.8) for details. */
export type GeoJsonGeometryCollection = GeoJsonGeometry &
  GeoJsonGeometryCollectionData & {};

/** Defines headers for Route_postRouteMatrix operation. */
export interface RoutePostRouteMatrixHeaders {
  /** New URL to check for the results of the long running process. */
  location?: string;
}

/** Defines headers for Route_postRouteDirectionsBatch operation. */
export interface RoutePostRouteDirectionsBatchHeaders {
  /** New URL to check for the results of the long running process. */
  location?: string;
}

/** Known values of {@link Geography} that the service accepts. */
export const enum KnownGeography {
  Us = "us",
  Eu = "eu"
}

/**
 * Defines values for Geography. \
 * {@link KnownGeography} can be used interchangeably with Geography,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **us** \
 * **eu**
 */
export type Geography = string;

/** Known values of {@link ResponseFormat} that the service accepts. */
export const enum KnownResponseFormat {
  /** [The JavaScript Object Notation Data Interchange Format](https://tools.ietf.org/html/rfc8259) */
  Json = "json"
}

/**
 * Defines values for ResponseFormat. \
 * {@link KnownResponseFormat} can be used interchangeably with ResponseFormat,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **json**: [The JavaScript Object Notation Data Interchange Format](https:\/\/tools.ietf.org\/html\/rfc8259)
 */
export type ResponseFormat = string;

/** Known values of {@link ComputeTravelTimeFor} that the service accepts. */
export const enum KnownComputeTravelTimeFor {
  /** Does not compute additional travel times. */
  None = "none",
  /** Computes travel times for all types of traffic information and specifies all results in the fields noTrafficTravelTimeInSeconds, historicTrafficTravelTimeInSeconds and liveTrafficIncidentsTravelTimeInSeconds being included in the summaries in the route response. */
  All = "all"
}

/**
 * Defines values for ComputeTravelTimeFor. \
 * {@link KnownComputeTravelTimeFor} can be used interchangeably with ComputeTravelTimeFor,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **none**: Does not compute additional travel times. \
 * **all**: Computes travel times for all types of traffic information and specifies all results in the fields noTrafficTravelTimeInSeconds, historicTrafficTravelTimeInSeconds and liveTrafficIncidentsTravelTimeInSeconds being included in the summaries in the route response.
 */
export type ComputeTravelTimeFor = string;

/** Known values of {@link SectionType} that the service accepts. */
export const enum KnownSectionType {
  /** Get sections if the route includes car trains. */
  CarTrain = "carTrain",
  /** Countries the route has parts in. */
  Country = "country",
  /** Get sections if the route includes ferries. */
  Ferry = "ferry",
  /** Get sections if the route includes motorways. */
  Motorway = "motorway",
  /** Get sections which are suited for pedestrians. */
  Pedestrian = "pedestrian",
  /** Get sections which require a toll to be payed. */
  TollRoad = "tollRoad",
  /** Get sections which require a toll vignette to be present. */
  TollVignette = "tollVignette",
  /** Get sections which contain traffic information. */
  Traffic = "traffic",
  /** Get sections in relation to the request parameter `travelMode`. */
  TravelMode = "travelMode",
  /** Get sections if the route includes tunnels. */
  Tunnel = "tunnel"
}

/**
 * Defines values for SectionType. \
 * {@link KnownSectionType} can be used interchangeably with SectionType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **carTrain**: Get sections if the route includes car trains. \
 * **country**: Countries the route has parts in. \
 * **ferry**: Get sections if the route includes ferries. \
 * **motorway**: Get sections if the route includes motorways. \
 * **pedestrian**: Get sections which are suited for pedestrians. \
 * **tollRoad**: Get sections which require a toll to be payed. \
 * **tollVignette**: Get sections which require a toll vignette to be present. \
 * **traffic**: Get sections which contain traffic information. \
 * **travelMode**: Get sections in relation to the request parameter `travelMode`. \
 * **tunnel**: Get sections if the route includes tunnels.
 */
export type SectionType = string;

/** Known values of {@link WindingnessLevel} that the service accepts. */
export const enum KnownWindingnessLevel {
  /** low */
  Low = "low",
  /** normal */
  Normal = "normal",
  /** high */
  High = "high"
}

/**
 * Defines values for WindingnessLevel. \
 * {@link KnownWindingnessLevel} can be used interchangeably with WindingnessLevel,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **low**: low \
 * **normal**: normal \
 * **high**: high
 */
export type WindingnessLevel = string;

/** Known values of {@link HillinessDegree} that the service accepts. */
export const enum KnownHillinessDegree {
  /** low */
  Low = "low",
  /** normal */
  Normal = "normal",
  /** high */
  High = "high"
}

/**
 * Defines values for HillinessDegree. \
 * {@link KnownHillinessDegree} can be used interchangeably with HillinessDegree,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **low**: low \
 * **normal**: normal \
 * **high**: high
 */
export type HillinessDegree = string;

/** Known values of {@link TravelMode} that the service accepts. */
export const enum KnownTravelMode {
  /** The returned routes are optimized for cars. */
  Car = "car",
  /** The returned routes are optimized for commercial vehicles, like for trucks. */
  Truck = "truck",
  /** The returned routes are optimized for taxis. BETA functionality. */
  Taxi = "taxi",
  /** The returned routes are optimized for buses, including the use of bus only lanes. BETA functionality. */
  Bus = "bus",
  /** The returned routes are optimized for vans. BETA functionality. */
  Van = "van",
  /** The returned routes are optimized for motorcycles. BETA functionality. */
  Motorcycle = "motorcycle",
  /** The returned routes are optimized for bicycles, including use of bicycle lanes. */
  Bicycle = "bicycle",
  /** The returned routes are optimized for pedestrians, including the use of sidewalks. */
  Pedestrian = "pedestrian"
}

/**
 * Defines values for TravelMode. \
 * {@link KnownTravelMode} can be used interchangeably with TravelMode,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **car**: The returned routes are optimized for cars. \
 * **truck**: The returned routes are optimized for commercial vehicles, like for trucks. \
 * **taxi**: The returned routes are optimized for taxis. BETA functionality. \
 * **bus**: The returned routes are optimized for buses, including the use of bus only lanes. BETA functionality. \
 * **van**: The returned routes are optimized for vans. BETA functionality. \
 * **motorcycle**: The returned routes are optimized for motorcycles. BETA functionality. \
 * **bicycle**: The returned routes are optimized for bicycles, including use of bicycle lanes. \
 * **pedestrian**: The returned routes are optimized for pedestrians, including the use of sidewalks.
 */
export type TravelMode = string;

/** Known values of {@link RouteAvoidType} that the service accepts. */
export const enum KnownRouteAvoidType {
  /** Avoids toll roads. */
  TollRoads = "tollRoads",
  /** Avoids motorways */
  Motorways = "motorways",
  /** Avoids ferries */
  Ferries = "ferries",
  /** Avoids unpaved roads */
  UnpavedRoads = "unpavedRoads",
  /** Avoids routes that require the use of carpool (HOV/High Occupancy Vehicle) lanes. */
  Carpools = "carpools",
  /** Avoids using the same road multiple times. Most useful in conjunction with `routeType`=thrilling. */
  AlreadyUsedRoads = "alreadyUsedRoads",
  /** Avoids border crossings in route calculation. */
  BorderCrossings = "borderCrossings"
}

/**
 * Defines values for RouteAvoidType. \
 * {@link KnownRouteAvoidType} can be used interchangeably with RouteAvoidType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **tollRoads**: Avoids toll roads. \
 * **motorways**: Avoids motorways \
 * **ferries**: Avoids ferries \
 * **unpavedRoads**: Avoids unpaved roads \
 * **carpools**: Avoids routes that require the use of carpool (HOV\/High Occupancy Vehicle) lanes. \
 * **alreadyUsedRoads**: Avoids using the same road multiple times. Most useful in conjunction with `routeType`=thrilling. \
 * **borderCrossings**: Avoids border crossings in route calculation.
 */
export type RouteAvoidType = string;

/** Known values of {@link RouteType} that the service accepts. */
export const enum KnownRouteType {
  /** The fastest route. */
  Fastest = "fastest",
  /** The shortest route by distance. */
  Shortest = "shortest",
  /** A route balanced by economy and speed. */
  Eco = "eco",
  /** Includes interesting or challenging roads and uses as few motorways as possible. You can choose the level of turns included and also the degree of hilliness. See the hilliness and windingness parameters for how to set this. There is a limit of 900 km on routes planned with `routeType`=thrilling */
  Thrilling = "thrilling"
}

/**
 * Defines values for RouteType. \
 * {@link KnownRouteType} can be used interchangeably with RouteType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **fastest**: The fastest route. \
 * **shortest**: The shortest route by distance. \
 * **eco**: A route balanced by economy and speed. \
 * **thrilling**: Includes interesting or challenging roads and uses as few motorways as possible. You can choose the level of turns included and also the degree of hilliness. See the hilliness and windingness parameters for how to set this. There is a limit of 900 km on routes planned with `routeType`=thrilling
 */
export type RouteType = string;

/** Known values of {@link VehicleLoadType} that the service accepts. */
export const enum KnownVehicleLoadType {
  /** Explosives */
  USHazmatClass1 = "USHazmatClass1",
  /** Compressed gas */
  USHazmatClass2 = "USHazmatClass2",
  /** Flammable liquids */
  USHazmatClass3 = "USHazmatClass3",
  /** Flammable solids */
  USHazmatClass4 = "USHazmatClass4",
  /** Oxidizers */
  USHazmatClass5 = "USHazmatClass5",
  /** Poisons */
  USHazmatClass6 = "USHazmatClass6",
  /** Radioactive */
  USHazmatClass7 = "USHazmatClass7",
  /** Corrosives */
  USHazmatClass8 = "USHazmatClass8",
  /** Miscellaneous */
  USHazmatClass9 = "USHazmatClass9",
  /** Explosives */
  OtherHazmatExplosive = "otherHazmatExplosive",
  /** Miscellaneous */
  OtherHazmatGeneral = "otherHazmatGeneral",
  /** Harmful to water */
  OtherHazmatHarmfulToWater = "otherHazmatHarmfulToWater"
}

/**
 * Defines values for VehicleLoadType. \
 * {@link KnownVehicleLoadType} can be used interchangeably with VehicleLoadType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **USHazmatClass1**: Explosives \
 * **USHazmatClass2**: Compressed gas \
 * **USHazmatClass3**: Flammable liquids \
 * **USHazmatClass4**: Flammable solids \
 * **USHazmatClass5**: Oxidizers \
 * **USHazmatClass6**: Poisons \
 * **USHazmatClass7**: Radioactive \
 * **USHazmatClass8**: Corrosives \
 * **USHazmatClass9**: Miscellaneous \
 * **otherHazmatExplosive**: Explosives \
 * **otherHazmatGeneral**: Miscellaneous \
 * **otherHazmatHarmfulToWater**: Harmful to water
 */
export type VehicleLoadType = string;

/** Known values of {@link GeoJsonObjectType} that the service accepts. */
export const enum KnownGeoJsonObjectType {
  /** `GeoJSON Point` geometry. */
  GeoJsonPoint = "Point",
  /** `GeoJSON MultiPoint` geometry. */
  GeoJsonMultiPoint = "MultiPoint",
  /** `GeoJSON LineString` geometry. */
  GeoJsonLineString = "LineString",
  /** `GeoJSON MultiLineString` geometry. */
  GeoJsonMultiLineString = "MultiLineString",
  /** `GeoJSON Polygon` geometry. */
  GeoJsonPolygon = "Polygon",
  /** `GeoJSON MultiPolygon` geometry. */
  GeoJsonMultiPolygon = "MultiPolygon",
  /** `GeoJSON GeometryCollection` geometry. */
  GeoJsonGeometryCollection = "GeometryCollection",
  /** `GeoJSON Feature` object. */
  GeoJsonFeature = "Feature",
  /** `GeoJSON FeatureCollection` object. */
  GeoJsonFeatureCollection = "FeatureCollection"
}

/**
 * Defines values for GeoJsonObjectType. \
 * {@link KnownGeoJsonObjectType} can be used interchangeably with GeoJsonObjectType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Point**: `GeoJSON Point` geometry. \
 * **MultiPoint**: `GeoJSON MultiPoint` geometry. \
 * **LineString**: `GeoJSON LineString` geometry. \
 * **MultiLineString**: `GeoJSON MultiLineString` geometry. \
 * **Polygon**: `GeoJSON Polygon` geometry. \
 * **MultiPolygon**: `GeoJSON MultiPolygon` geometry. \
 * **GeometryCollection**: `GeoJSON GeometryCollection` geometry. \
 * **Feature**: `GeoJSON Feature` object. \
 * **FeatureCollection**: `GeoJSON FeatureCollection` object.
 */
export type GeoJsonObjectType = string;

/** Known values of {@link TextFormat} that the service accepts. */
export const enum KnownTextFormat {
  /** [The JavaScript Object Notation Data Interchange Format](https://tools.ietf.org/html/rfc8259) */
  Json = "json",
  /** [The Extensible Markup Language](https://www.w3.org/TR/xml/) */
  Xml = "xml"
}

/**
 * Defines values for TextFormat. \
 * {@link KnownTextFormat} can be used interchangeably with TextFormat,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **json**: [The JavaScript Object Notation Data Interchange Format](https:\/\/tools.ietf.org\/html\/rfc8259) \
 * **xml**: [The Extensible Markup Language](https:\/\/www.w3.org\/TR\/xml\/)
 */
export type TextFormat = string;

/** Known values of {@link AlternativeRouteType} that the service accepts. */
export const enum KnownAlternativeRouteType {
  /** Allow any alternative route to be returned irrespective of how it compares to the reference route in terms of optimality. */
  AnyRoute = "anyRoute",
  /** Return an alternative route only if it is better than the reference route according to the given planning criteria. */
  BetterRoute = "betterRoute"
}

/**
 * Defines values for AlternativeRouteType. \
 * {@link KnownAlternativeRouteType} can be used interchangeably with AlternativeRouteType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **anyRoute**: Allow any alternative route to be returned irrespective of how it compares to the reference route in terms of optimality. \
 * **betterRoute**: Return an alternative route only if it is better than the reference route according to the given planning criteria.
 */
export type AlternativeRouteType = string;

/** Known values of {@link RouteInstructionsType} that the service accepts. */
export const enum KnownRouteInstructionsType {
  /** Returns raw instruction data without human-readable messages. */
  Coded = "coded",
  /** Returns raw instructions data with human-readable messages in plain text. */
  Text = "text",
  /**
   * Returns raw instruction data with tagged human-readable messages to permit formatting. A human-readable message is built up from repeatable identified elements. These are tagged to allow client applications to format them correctly. The following message components are tagged when instructionsType=tagged: street, roadNumber, signpostText, exitNumber, roundaboutExitNumber.
   *
   * Example of tagged 'Turn left' message:​
   *
   * ```
   * Turn left onto <roadNumber>A4</roadNumber>/<roadNumber>E19</roadNumber>
   * towards <signpostText>Den Haag</signpostText>
   * ```
   */
  Tagged = "tagged"
}

/**
 * Defines values for RouteInstructionsType. \
 * {@link KnownRouteInstructionsType} can be used interchangeably with RouteInstructionsType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **coded**: Returns raw instruction data without human-readable messages. \
 * **text**: Returns raw instructions data with human-readable messages in plain text. \
 * **tagged**: Returns raw instruction data with tagged human-readable messages to permit formatting. A human-readable message is built up from repeatable identified elements. These are tagged to allow client applications to format them correctly. The following message components are tagged when instructionsType=tagged: street, roadNumber, signpostText, exitNumber, roundaboutExitNumber.
 *
 * Example of tagged 'Turn left' message:​
 *
 * ```
 * Turn left onto <roadNumber>A4<\/roadNumber>\/<roadNumber>E19<\/roadNumber>
 * towards <signpostText>Den Haag<\/signpostText>
 * ```
 */
export type RouteInstructionsType = string;

/** Known values of {@link RouteRepresentation} that the service accepts. */
export const enum KnownRouteRepresentation {
  /** Includes route geometry in the response. */
  Polyline = "polyline",
  /** Summary as per polyline but excluding the point geometry elements for the routes in the response. */
  SummaryOnly = "summaryOnly",
  /** Includes only the optimized waypoint indices but does not include the route geometry in the response. */
  None = "none"
}

/**
 * Defines values for RouteRepresentation. \
 * {@link KnownRouteRepresentation} can be used interchangeably with RouteRepresentation,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **polyline**: Includes route geometry in the response. \
 * **summaryOnly**: Summary as per polyline but excluding the point geometry elements for the routes in the response. \
 * **none**: Includes only the optimized waypoint indices but does not include the route geometry in the response.
 */
export type RouteRepresentation = string;

/** Known values of {@link VehicleEngineType} that the service accepts. */
export const enum KnownVehicleEngineType {
  /** Internal combustion engine. */
  Combustion = "combustion",
  /** Electric engine. */
  Electric = "electric"
}

/**
 * Defines values for VehicleEngineType. \
 * {@link KnownVehicleEngineType} can be used interchangeably with VehicleEngineType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **combustion**: Internal combustion engine. \
 * **electric**: Electric engine.
 */
export type VehicleEngineType = string;

/** Known values of {@link MagnitudeOfDelay} that the service accepts. */
export const enum KnownMagnitudeOfDelay {
  /** Unknown. */
  Zero = "0",
  /** Minor. */
  One = "1",
  /** Moderate. */
  Two = "2",
  /** Major. */
  Three = "3",
  /** Undefined, used for road closures and other indefinite delays. */
  Four = "4"
}

/**
 * Defines values for MagnitudeOfDelay. \
 * {@link KnownMagnitudeOfDelay} can be used interchangeably with MagnitudeOfDelay,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **0**: Unknown. \
 * **1**: Minor. \
 * **2**: Moderate. \
 * **3**: Major. \
 * **4**: Undefined, used for road closures and other indefinite delays.
 */
export type MagnitudeOfDelay = string;

/** Known values of {@link GuidanceInstructionType} that the service accepts. */
export const enum KnownGuidanceInstructionType {
  /** Turn. */
  Turn = "TURN",
  /** Road Change. */
  RoadChange = "ROAD_CHANGE",
  /** Departure location. */
  LocationDeparture = "LOCATION_DEPARTURE",
  /** Arrival location. */
  LocationArrival = "LOCATION_ARRIVAL",
  /** Direction information. */
  DirectionInfo = "DIRECTION_INFO",
  /** Way point location. */
  LocationWaypoint = "LOCATION_WAYPOINT"
}

/**
 * Defines values for GuidanceInstructionType. \
 * {@link KnownGuidanceInstructionType} can be used interchangeably with GuidanceInstructionType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **TURN**: Turn. \
 * **ROAD_CHANGE**: Road Change. \
 * **LOCATION_DEPARTURE**: Departure location. \
 * **LOCATION_ARRIVAL**: Arrival location. \
 * **DIRECTION_INFO**: Direction information. \
 * **LOCATION_WAYPOINT**: Way point location.
 */
export type GuidanceInstructionType = string;

/** Known values of {@link JunctionType} that the service accepts. */
export const enum KnownJunctionType {
  /** regular */
  Regular = "REGULAR",
  /** roundabout */
  Roundabout = "ROUNDABOUT",
  /** bifurcation */
  Bifurcation = "BIFURCATION"
}

/**
 * Defines values for JunctionType. \
 * {@link KnownJunctionType} can be used interchangeably with JunctionType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **REGULAR**: regular \
 * **ROUNDABOUT**: roundabout \
 * **BIFURCATION**: bifurcation
 */
export type JunctionType = string;

/** Known values of {@link DrivingSide} that the service accepts. */
export const enum KnownDrivingSide {
  /** Left side. */
  Left = "LEFT",
  /** Right side. */
  Right = "RIGHT"
}

/**
 * Defines values for DrivingSide. \
 * {@link KnownDrivingSide} can be used interchangeably with DrivingSide,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **LEFT**: Left side. \
 * **RIGHT**: Right side.
 */
export type DrivingSide = string;

/** Known values of {@link GuidanceManeuver} that the service accepts. */
export const enum KnownGuidanceManeuver {
  /** You have arrived. */
  Arrive = "ARRIVE",
  /** You have arrived. Your destination is on the left. */
  ArriveLeft = "ARRIVE_LEFT",
  /** You have arrived. Your destination is on the right. */
  ArriveRight = "ARRIVE_RIGHT",
  /** Leave. */
  Depart = "DEPART",
  /** Keep straight on. */
  Straight = "STRAIGHT",
  /** Keep right. */
  KeepRight = "KEEP_RIGHT",
  /** Bear right. */
  BearRight = "BEAR_RIGHT",
  /** Turn right. */
  TurnRight = "TURN_RIGHT",
  /** Turn sharp right. */
  SharpRight = "SHARP_RIGHT",
  /** Keep left. */
  KeepLeft = "KEEP_LEFT",
  /** Bear left. */
  BearLeft = "BEAR_LEFT",
  /** Turn left. */
  TurnLeft = "TURN_LEFT",
  /** Turn sharp left. */
  SharpLeft = "SHARP_LEFT",
  /** Make a U-turn. */
  MakeUturn = "MAKE_UTURN",
  /** Take the motorway. */
  EnterMotorway = "ENTER_MOTORWAY",
  /** Take the freeway. */
  EnterFreeway = "ENTER_FREEWAY",
  /** Take the highway. */
  EnterHighway = "ENTER_HIGHWAY",
  /** Take the exit. */
  TakeExit = "TAKE_EXIT",
  /** Take the left exit. */
  MotorwayExitLeft = "MOTORWAY_EXIT_LEFT",
  /** Take the right exit. */
  MotorwayExitRight = "MOTORWAY_EXIT_RIGHT",
  /** Take the ferry. */
  TakeFerry = "TAKE_FERRY",
  /** Cross the roundabout. */
  RoundaboutCross = "ROUNDABOUT_CROSS",
  /** At the roundabout take the exit on the right. */
  RoundaboutRight = "ROUNDABOUT_RIGHT",
  /** At the roundabout take the exit on the left. */
  RoundaboutLeft = "ROUNDABOUT_LEFT",
  /** Go around the roundabout. */
  RoundaboutBack = "ROUNDABOUT_BACK",
  /** Try to make a U-turn. */
  TRYMakeUturn = "TRY_MAKE_UTURN",
  /** Follow. */
  Follow = "FOLLOW",
  /** Switch to the parallel road. */
  SwitchParallelRoad = "SWITCH_PARALLEL_ROAD",
  /** Switch to the main road. */
  SwitchMainRoad = "SWITCH_MAIN_ROAD",
  /** Take the ramp. */
  EntranceRamp = "ENTRANCE_RAMP",
  /** You have reached the waypoint. It is on the left. */
  WaypointLeft = "WAYPOINT_LEFT",
  /** You have reached the waypoint. It is on the right. */
  WaypointRight = "WAYPOINT_RIGHT",
  /** You have reached the waypoint. */
  WaypointReached = "WAYPOINT_REACHED"
}

/**
 * Defines values for GuidanceManeuver. \
 * {@link KnownGuidanceManeuver} can be used interchangeably with GuidanceManeuver,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **ARRIVE**: You have arrived. \
 * **ARRIVE_LEFT**: You have arrived. Your destination is on the left. \
 * **ARRIVE_RIGHT**: You have arrived. Your destination is on the right. \
 * **DEPART**: Leave. \
 * **STRAIGHT**: Keep straight on. \
 * **KEEP_RIGHT**: Keep right. \
 * **BEAR_RIGHT**: Bear right. \
 * **TURN_RIGHT**: Turn right. \
 * **SHARP_RIGHT**: Turn sharp right. \
 * **KEEP_LEFT**: Keep left. \
 * **BEAR_LEFT**: Bear left. \
 * **TURN_LEFT**: Turn left. \
 * **SHARP_LEFT**: Turn sharp left. \
 * **MAKE_UTURN**: Make a U-turn. \
 * **ENTER_MOTORWAY**: Take the motorway. \
 * **ENTER_FREEWAY**: Take the freeway. \
 * **ENTER_HIGHWAY**: Take the highway. \
 * **TAKE_EXIT**: Take the exit. \
 * **MOTORWAY_EXIT_LEFT**: Take the left exit. \
 * **MOTORWAY_EXIT_RIGHT**: Take the right exit. \
 * **TAKE_FERRY**: Take the ferry. \
 * **ROUNDABOUT_CROSS**: Cross the roundabout. \
 * **ROUNDABOUT_RIGHT**: At the roundabout take the exit on the right. \
 * **ROUNDABOUT_LEFT**: At the roundabout take the exit on the left. \
 * **ROUNDABOUT_BACK**: Go around the roundabout. \
 * **TRY_MAKE_UTURN**: Try to make a U-turn. \
 * **FOLLOW**: Follow. \
 * **SWITCH_PARALLEL_ROAD**: Switch to the parallel road. \
 * **SWITCH_MAIN_ROAD**: Switch to the main road. \
 * **ENTRANCE_RAMP**: Take the ramp. \
 * **WAYPOINT_LEFT**: You have reached the waypoint. It is on the left. \
 * **WAYPOINT_RIGHT**: You have reached the waypoint. It is on the right. \
 * **WAYPOINT_REACHED**: You have reached the waypoint.
 */
export type GuidanceManeuver = string;

/** Known values of {@link GeographicResourceLocation} that the service accepts. */
export const enum KnownGeographicResourceLocation {
  /** Used to access an Azure Maps Creator resource in the United States */
  Us = "us",
  /** Used to access an Azure Maps Creator resource in Europe */
  Eu = "eu"
}

/**
 * Defines values for GeographicResourceLocation. \
 * {@link KnownGeographicResourceLocation} can be used interchangeably with GeographicResourceLocation,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **us**: Used to access an Azure Maps Creator resource in the United States \
 * **eu**: Used to access an Azure Maps Creator resource in Europe
 */
export type GeographicResourceLocation = string;

/** Optional parameters. */
export interface RoutePostRouteMatrixOptionalParams
  extends coreClient.OperationOptions {
  /** Boolean to indicate whether to execute the request synchronously. If set to true, user will get a 200 response if the request is finished under 120 seconds. Otherwise, user will get a 202 response right away. Please refer to the API description for more details on 202 response. **Supported only for async request**. */
  waitForResults?: boolean;
  /** Specifies whether to return additional travel times using different types of traffic information (none, historic, live) as well as the default best-estimate travel time. */
  computeTravelTimeFor?: ComputeTravelTimeFor;
  /** Specifies which of the section types is reported in the route response. <br><br>For example if sectionType = pedestrian the sections which are suited for pedestrians only are returned. Multiple types can be used. The default sectionType refers to the travelMode input. By default travelMode is set to car */
  sectionType?: SectionType;
  /** The date and time of arrival at the destination point. It must be specified as a dateTime. When a time zone offset is not specified it will be assumed to be that of the destination point. The arriveAt value must be in the future. The arriveAt parameter cannot be used in conjunction with departAt, minDeviationDistance or minDeviationTime. */
  arriveAt?: Date;
  /** The date and time of departure from the origin point. Departure times apart from now must be specified as a dateTime. When a time zone offset is not specified, it will be assumed to be that of the origin point. The departAt value must be in the future in the date-time format (1996-12-19T16:39:57-08:00). */
  departAt?: Date;
  /** Weight per axle of the vehicle in kg. A value of 0 means that weight restrictions per axle are not considered. */
  vehicleAxleWeight?: number;
  /** Length of the vehicle in meters. A value of 0 means that length restrictions are not considered. */
  vehicleLength?: number;
  /** Height of the vehicle in meters. A value of 0 means that height restrictions are not considered. */
  vehicleHeight?: number;
  /** Width of the vehicle in meters. A value of 0 means that width restrictions are not considered. */
  vehicleWidth?: number;
  /**
   * Maximum speed of the vehicle in km/hour. The max speed in the vehicle profile is used to check whether a vehicle is allowed on motorways.
   *
   * * A value of 0 means that an appropriate value for the vehicle will be determined and applied during route planning.
   *
   * * A non-zero value may be overridden during route planning. For example, the current traffic flow is 60 km/hour. If the vehicle  maximum speed is set to 50 km/hour, the routing engine will consider 60 km/hour as this is the current situation.  If the maximum speed of the vehicle is provided as 80 km/hour but the current traffic flow is 60 km/hour, then routing engine will again use 60 km/hour.
   */
  vehicleMaxSpeed?: number;
  /** Weight of the vehicle in kilograms. */
  vehicleWeight?: number;
  /** Level of turns for thrilling route. This parameter can only be used in conjunction with `routeType`=thrilling. */
  windingness?: WindingnessLevel;
  /** Degree of hilliness for thrilling route. This parameter can only be used in conjunction with `routeType`=thrilling. */
  hilliness?: HillinessDegree;
  /** The mode of travel for the requested route. If not defined, default is 'car'. Note that the requested travelMode may not be available for the entire route. Where the requested travelMode is not available for a particular section, the travelMode element of the response for that section will be "other". Note that travel modes bus, motorcycle, taxi and van are BETA functionality. Full restriction data is not available in all areas. In **calculateReachableRange** requests, the values bicycle and pedestrian must not be used. */
  travelMode?: TravelMode;
  /** Specifies something that the route calculation should try to avoid when determining the route. Can be specified multiple times in one request, for example, '&avoid=motorways&avoid=tollRoads&avoid=ferries'. In calculateReachableRange requests, the value alreadyUsedRoads must not be used. */
  avoid?: RouteAvoidType[];
  /**
   * Possible values:
   *   * true - Do consider all available traffic information during routing
   *   * false - Ignore current traffic data during routing. Note that although the current traffic data is ignored
   *   during routing, the effect of historic traffic on effective road speeds is still incorporated.
   */
  traffic?: boolean;
  /** The type of route requested. */
  routeType?: RouteType;
  /** Types of cargo that may be classified as hazardous materials and restricted from some roads. Available vehicleLoadType values are US Hazmat classes 1 through 9, plus generic classifications for use in other countries. Values beginning with USHazmat are for US routing while otherHazmat should be used for all other countries. vehicleLoadType can be specified multiple times. This parameter is currently only considered for travelMode=truck. */
  vehicleLoadType?: VehicleLoadType;
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Contains response data for the postRouteMatrix operation. */
export type RoutePostRouteMatrixResponse = RouteMatrixResponse;

/** Optional parameters. */
export interface RoutePostRouteMatrixSyncOptionalParams
  extends coreClient.OperationOptions {
  /** Boolean to indicate whether to execute the request synchronously. If set to true, user will get a 200 response if the request is finished under 120 seconds. Otherwise, user will get a 202 response right away. Please refer to the API description for more details on 202 response. **Supported only for async request**. */
  waitForResults?: boolean;
  /** Specifies whether to return additional travel times using different types of traffic information (none, historic, live) as well as the default best-estimate travel time. */
  computeTravelTimeFor?: ComputeTravelTimeFor;
  /** Specifies which of the section types is reported in the route response. <br><br>For example if sectionType = pedestrian the sections which are suited for pedestrians only are returned. Multiple types can be used. The default sectionType refers to the travelMode input. By default travelMode is set to car */
  sectionType?: SectionType;
  /** The date and time of arrival at the destination point. It must be specified as a dateTime. When a time zone offset is not specified it will be assumed to be that of the destination point. The arriveAt value must be in the future. The arriveAt parameter cannot be used in conjunction with departAt, minDeviationDistance or minDeviationTime. */
  arriveAt?: Date;
  /** The date and time of departure from the origin point. Departure times apart from now must be specified as a dateTime. When a time zone offset is not specified, it will be assumed to be that of the origin point. The departAt value must be in the future in the date-time format (1996-12-19T16:39:57-08:00). */
  departAt?: Date;
  /** Weight per axle of the vehicle in kg. A value of 0 means that weight restrictions per axle are not considered. */
  vehicleAxleWeight?: number;
  /** Length of the vehicle in meters. A value of 0 means that length restrictions are not considered. */
  vehicleLength?: number;
  /** Height of the vehicle in meters. A value of 0 means that height restrictions are not considered. */
  vehicleHeight?: number;
  /** Width of the vehicle in meters. A value of 0 means that width restrictions are not considered. */
  vehicleWidth?: number;
  /**
   * Maximum speed of the vehicle in km/hour. The max speed in the vehicle profile is used to check whether a vehicle is allowed on motorways.
   *
   * * A value of 0 means that an appropriate value for the vehicle will be determined and applied during route planning.
   *
   * * A non-zero value may be overridden during route planning. For example, the current traffic flow is 60 km/hour. If the vehicle  maximum speed is set to 50 km/hour, the routing engine will consider 60 km/hour as this is the current situation.  If the maximum speed of the vehicle is provided as 80 km/hour but the current traffic flow is 60 km/hour, then routing engine will again use 60 km/hour.
   */
  vehicleMaxSpeed?: number;
  /** Weight of the vehicle in kilograms. */
  vehicleWeight?: number;
  /** Level of turns for thrilling route. This parameter can only be used in conjunction with `routeType`=thrilling. */
  windingness?: WindingnessLevel;
  /** Degree of hilliness for thrilling route. This parameter can only be used in conjunction with `routeType`=thrilling. */
  hilliness?: HillinessDegree;
  /** The mode of travel for the requested route. If not defined, default is 'car'. Note that the requested travelMode may not be available for the entire route. Where the requested travelMode is not available for a particular section, the travelMode element of the response for that section will be "other". Note that travel modes bus, motorcycle, taxi and van are BETA functionality. Full restriction data is not available in all areas. In **calculateReachableRange** requests, the values bicycle and pedestrian must not be used. */
  travelMode?: TravelMode;
  /** Specifies something that the route calculation should try to avoid when determining the route. Can be specified multiple times in one request, for example, '&avoid=motorways&avoid=tollRoads&avoid=ferries'. In calculateReachableRange requests, the value alreadyUsedRoads must not be used. */
  avoid?: RouteAvoidType[];
  /**
   * Possible values:
   *   * true - Do consider all available traffic information during routing
   *   * false - Ignore current traffic data during routing. Note that although the current traffic data is ignored
   *   during routing, the effect of historic traffic on effective road speeds is still incorporated.
   */
  traffic?: boolean;
  /** The type of route requested. */
  routeType?: RouteType;
  /** Types of cargo that may be classified as hazardous materials and restricted from some roads. Available vehicleLoadType values are US Hazmat classes 1 through 9, plus generic classifications for use in other countries. Values beginning with USHazmat are for US routing while otherHazmat should be used for all other countries. vehicleLoadType can be specified multiple times. This parameter is currently only considered for travelMode=truck. */
  vehicleLoadType?: VehicleLoadType;
}

/** Contains response data for the postRouteMatrixSync operation. */
export type RoutePostRouteMatrixSyncResponse = RouteMatrixResponse;

/** Optional parameters. */
export interface RouteGetRouteDirectionsOptionalParams
  extends coreClient.OperationOptions {
  /** Specifies whether to return additional travel times using different types of traffic information (none, historic, live) as well as the default best-estimate travel time. */
  computeTravelTimeFor?: ComputeTravelTimeFor;
  /** Specifies which of the section types is reported in the route response. <br><br>For example if sectionType = pedestrian the sections which are suited for pedestrians only are returned. Multiple types can be used. The default sectionType refers to the travelMode input. By default travelMode is set to car */
  sectionType?: SectionType;
  /** The date and time of arrival at the destination point. It must be specified as a dateTime. When a time zone offset is not specified it will be assumed to be that of the destination point. The arriveAt value must be in the future. The arriveAt parameter cannot be used in conjunction with departAt, minDeviationDistance or minDeviationTime. */
  arriveAt?: Date;
  /** The date and time of departure from the origin point. Departure times apart from now must be specified as a dateTime. When a time zone offset is not specified, it will be assumed to be that of the origin point. The departAt value must be in the future in the date-time format (1996-12-19T16:39:57-08:00). */
  departAt?: Date;
  /** Weight per axle of the vehicle in kg. A value of 0 means that weight restrictions per axle are not considered. */
  vehicleAxleWeight?: number;
  /** Length of the vehicle in meters. A value of 0 means that length restrictions are not considered. */
  vehicleLength?: number;
  /** Height of the vehicle in meters. A value of 0 means that height restrictions are not considered. */
  vehicleHeight?: number;
  /** Width of the vehicle in meters. A value of 0 means that width restrictions are not considered. */
  vehicleWidth?: number;
  /**
   * Maximum speed of the vehicle in km/hour. The max speed in the vehicle profile is used to check whether a vehicle is allowed on motorways.
   *
   * * A value of 0 means that an appropriate value for the vehicle will be determined and applied during route planning.
   *
   * * A non-zero value may be overridden during route planning. For example, the current traffic flow is 60 km/hour. If the vehicle  maximum speed is set to 50 km/hour, the routing engine will consider 60 km/hour as this is the current situation.  If the maximum speed of the vehicle is provided as 80 km/hour but the current traffic flow is 60 km/hour, then routing engine will again use 60 km/hour.
   */
  vehicleMaxSpeed?: number;
  /**
   * Weight of the vehicle in kilograms.
   *
   * * It is mandatory if any of the *Efficiency parameters are set.
   *
   * * It must be strictly positive when used in the context of the Consumption Model. Weight restrictions are considered.
   *
   * * If no detailed **Consumption Model** is specified and the value of **vehicleWeight** is non-zero, then weight restrictions are considered.
   *
   * * In all other cases, this parameter is ignored.
   *
   * Sensible Values : for **Combustion Model** : 1600, for **Electric Model** : 1900
   */
  vehicleWeight?: number;
  /** Level of turns for thrilling route. This parameter can only be used in conjunction with `routeType`=thrilling. */
  windingness?: WindingnessLevel;
  /** Degree of hilliness for thrilling route. This parameter can only be used in conjunction with `routeType`=thrilling. */
  hilliness?: HillinessDegree;
  /** The mode of travel for the requested route. If not defined, default is 'car'. Note that the requested travelMode may not be available for the entire route. Where the requested travelMode is not available for a particular section, the travelMode element of the response for that section will be "other". Note that travel modes bus, motorcycle, taxi and van are BETA functionality. Full restriction data is not available in all areas. In **calculateReachableRange** requests, the values bicycle and pedestrian must not be used. */
  travelMode?: TravelMode;
  /** Specifies something that the route calculation should try to avoid when determining the route. Can be specified multiple times in one request, for example, '&avoid=motorways&avoid=tollRoads&avoid=ferries'. In calculateReachableRange requests, the value alreadyUsedRoads must not be used. */
  avoid?: RouteAvoidType[];
  /**
   * Possible values:
   *   * true - Do consider all available traffic information during routing
   *   * false - Ignore current traffic data during routing. Note that although the current traffic data is ignored
   *   during routing, the effect of historic traffic on effective road speeds is still incorporated.
   */
  traffic?: boolean;
  /** The type of route requested. */
  routeType?: RouteType;
  /** Types of cargo that may be classified as hazardous materials and restricted from some roads. Available vehicleLoadType values are US Hazmat classes 1 through 9, plus generic classifications for use in other countries. Values beginning with USHazmat are for US routing while otherHazmat should be used for all other countries. vehicleLoadType can be specified multiple times. This parameter is currently only considered for travelMode=truck. */
  vehicleLoadType?: VehicleLoadType;
  /** Number of desired alternative routes to be calculated. Default: 0, minimum: 0 and maximum: 5 */
  maxAlternatives?: number;
  /** Controls the optimality, with respect to the given planning criteria, of the calculated alternatives compared to the reference route. */
  alternativeType?: AlternativeRouteType;
  /** All alternative routes returned will follow the reference route (see section POST Requests) from the origin point of the calculateRoute request for at least this number of meters. Can only be used when reconstructing a route. The minDeviationDistance parameter cannot be used in conjunction with arriveAt */
  minDeviationDistance?: number;
  /**
   * All alternative routes returned will follow the reference route (see section POST Requests) from the origin point of the calculateRoute request for at least this number of seconds. Can only be used when reconstructing a route. The minDeviationTime parameter cannot be used in conjunction with arriveAt. Default value is 0. Setting )minDeviationTime_ to a value greater than zero has the following consequences:
   *   - The origin point of the _calculateRoute_ Request must be on
   *     (or very near) the input reference route.
   *     - If this is not the case, an error is returned.
   *     - However, the origin point does not need to be at the beginning
   *       of the input reference route (it can be thought of as the current
   *       vehicle position on the reference route).
   *   - The reference route, returned as the first route in the _calculateRoute_
   *     Response, will start at the origin point specified in the _calculateRoute_
   *     Request. The initial part of the input reference route up until the origin
   *     point will be excluded from the Response.
   *   - The values of _minDeviationDistance_ and _minDeviationTime_ determine
   *     how far alternative routes will be guaranteed to follow the reference
   *     route from the origin point onwards.
   *   - The route must use _departAt_.
   *   - The _vehicleHeading_ is ignored.
   */
  minDeviationTime?: number;
  /** If specified, guidance instructions will be returned. Note that the instructionsType parameter cannot be used in conjunction with routeRepresentation=none */
  instructionsType?: RouteInstructionsType;
  /**
   * The language parameter determines the language of the guidance messages. Proper nouns (the names of streets, plazas, etc.) are returned in the specified  language, or if that is not available, they are returned in an available language  that is close to it. Allowed values are (a subset of) the IETF language tags. The currently supported  languages are listed in the [Supported languages  section](https://docs.microsoft.com/azure/azure-maps/supported-languages).
   *
   * Default value: en-GB
   */
  language?: string;
  /** Re-order the route waypoints using a fast heuristic algorithm to reduce the route length. Yields best results when used in conjunction with routeType _shortest_. Notice that origin and destination are excluded from the optimized waypoint indices. To include origin and destination in the response, please increase all the indices by 1 to account for the origin, and then add the destination as the final index. Possible values are true or false. True computes a better order if possible, but is not allowed to be used in conjunction with maxAlternatives value greater than 0 or in conjunction with circle waypoints. False will use the locations in the given order and not allowed to be used in conjunction with routeRepresentation _none_. */
  computeBestOrder?: boolean;
  /** Specifies the representation of the set of routes provided as response. This parameter value can only be used in conjunction with computeBestOrder=true. */
  routeRepresentation?: RouteRepresentation;
  /** The directional heading of the vehicle in degrees starting at true North and continuing in clockwise direction. North is 0 degrees, east is 90 degrees, south is 180 degrees, west is 270 degrees. Possible values 0-359 */
  vehicleHeading?: number;
  /** Specifies which data should be reported for diagnosis purposes. The only possible value is _effectiveSettings_. Reports the effective parameters or data used when calling the API. In the case of defaulted parameters the default will be reflected where the parameter was not specified by the caller. */
  report?: string;
  /** Vehicle is used for commercial purposes and thus may not be allowed to drive  on some roads. */
  vehicleCommercial?: boolean;
  /** Engine type of the vehicle. When a detailed Consumption Model is specified, it must be consistent with the value of **vehicleEngineType**. */
  vehicleEngineType?: VehicleEngineType;
  /**
   *
   * Specifies the speed-dependent component of consumption.
   *
   * Provided as an unordered list of colon-delimited speed & consumption-rate pairs. The list defines points on a consumption curve. Consumption rates for speeds not in the list are found as follows:
   *
   *  * by linear interpolation, if the given speed lies in between two speeds in the list
   *
   *  * by linear extrapolation otherwise, assuming a constant (ΔConsumption/ΔSpeed) determined by the nearest two points in the list
   *
   * The list must contain between 1 and 25 points (inclusive), and may not contain duplicate points for the same speed. If it only contains a single point, then the consumption rate of that point is used without further processing.
   *
   * Consumption specified for the largest speed must be greater than or equal to that of the penultimate largest speed. This ensures that extrapolation does not lead to negative consumption rates.
   *
   * Similarly, consumption values specified for the two smallest speeds in the list cannot lead to a negative consumption rate for any smaller speed.
   *
   * The valid range for the consumption values(expressed in l/100km) is between 0.01 and 100000.0.
   *
   * Sensible Values : 50,6.3:130,11.5
   *
   * **Note** : This parameter is required for **The Combustion Consumption Model**.
   */
  constantSpeedConsumptionInLitersPerHundredkm?: number;
  /**
   * Specifies the current supply of fuel in liters.
   *
   * Sensible Values : 55
   */
  currentFuelInLiters?: number;
  /**
   * Specifies the amount of fuel consumed for sustaining auxiliary systems of the vehicle, in liters per hour.
   *
   * It can be used to specify consumption due to devices and systems such as AC systems, radio, heating, etc.
   *
   * Sensible Values : 0.2
   */
  auxiliaryPowerInLitersPerHour?: number;
  /**
   * Specifies the amount of chemical energy stored in one liter of fuel in megajoules (MJ). It is used in conjunction with the ***Efficiency** parameters for conversions between saved or consumed energy and fuel. For example, energy density is 34.2 MJ/l for gasoline, and 35.8 MJ/l for Diesel fuel.
   *
   * This parameter is required if any ***Efficiency** parameter is set.
   *
   * Sensible Values : 34.2
   */
  fuelEnergyDensityInMJoulesPerLiter?: number;
  /**
   * Specifies the efficiency of converting chemical energy stored in fuel to kinetic energy when the vehicle accelerates _(i.e. KineticEnergyGained/ChemicalEnergyConsumed). ChemicalEnergyConsumed_ is obtained by converting consumed fuel to chemical energy using **fuelEnergyDensityInMJoulesPerLiter**.
   *
   * Must be paired with **decelerationEfficiency**.
   *
   * The range of values allowed are 0.0 to 1/**decelerationEfficiency**.
   *
   * Sensible Values : for **Combustion Model** : 0.33, for **Electric Model** : 0.66
   */
  accelerationEfficiency?: number;
  /**
   * Specifies the efficiency of converting kinetic energy to saved (not consumed) fuel when the vehicle decelerates _(i.e. ChemicalEnergySaved/KineticEnergyLost). ChemicalEnergySaved_ is obtained by converting saved (not consumed) fuel to energy using **fuelEnergyDensityInMJoulesPerLiter**.
   *
   * Must be paired with **accelerationEfficiency**.
   *
   * The range of values allowed are 0.0 to 1/**accelerationEfficiency**.
   *
   * Sensible Values : for **Combustion Model** : 0.83, for **Electric Model** : 0.91
   */
  decelerationEfficiency?: number;
  /**
   * Specifies the efficiency of converting chemical energy stored in fuel to potential energy when the vehicle gains elevation _(i.e. PotentialEnergyGained/ChemicalEnergyConsumed). ChemicalEnergyConsumed_ is obtained by converting consumed fuel to chemical energy using **fuelEnergyDensityInMJoulesPerLiter**.
   *
   * Must be paired with **downhillEfficiency**.
   *
   * The range of values allowed are 0.0 to 1/**downhillEfficiency**.
   *
   * Sensible Values : for **Combustion Model** : 0.27, for **Electric Model** : 0.74
   */
  uphillEfficiency?: number;
  /**
   * Specifies the efficiency of converting potential energy to saved (not consumed) fuel when the vehicle loses elevation _(i.e. ChemicalEnergySaved/PotentialEnergyLost). ChemicalEnergySaved_ is obtained by converting saved (not consumed) fuel to energy using **fuelEnergyDensityInMJoulesPerLiter**.
   *
   * Must be paired with **uphillEfficiency**.
   *
   * The range of values allowed are 0.0 to 1/**uphillEfficiency**.
   *
   * Sensible Values : for **Combustion Model** : 0.51, for **Electric Model** : 0.73
   */
  downhillEfficiency?: number;
  /**
   * Specifies the speed-dependent component of consumption.
   *
   * Provided as an unordered list of speed/consumption-rate pairs. The list defines points on a consumption curve. Consumption rates for speeds not in the list are found as follows:
   *
   * * by linear interpolation, if the given speed lies in between two speeds in the list
   *
   * * by linear extrapolation otherwise, assuming a constant (ΔConsumption/ΔSpeed) determined by the nearest two points in the list
   *
   * The list must contain between 1 and 25 points (inclusive), and may not contain duplicate points for the same speed. If it only contains a single point, then the consumption rate of that point is used without further processing.
   *
   * Consumption specified for the largest speed must be greater than or equal to that of the penultimate largest speed. This ensures that extrapolation does not lead to negative consumption rates.
   *
   * Similarly, consumption values specified for the two smallest speeds in the list cannot lead to a negative consumption rate for any smaller  speed.
   *
   * The valid range for the consumption values(expressed in kWh/100km) is between 0.01 and 100000.0.
   *
   * Sensible Values : 50,8.2:130,21.3
   *
   * This parameter is required for **Electric consumption model**.
   */
  constantSpeedConsumptionInkWhPerHundredkm?: string;
  /**
   * Specifies the current electric energy supply in kilowatt hours (kWh).
   *
   * This parameter co-exists with **maxChargeInkWh** parameter.
   *
   * The range of values allowed are 0.0 to **maxChargeInkWh**.
   *
   * Sensible Values : 43
   */
  currentChargeInkWh?: string;
  /**
   * Specifies the maximum electric energy supply in kilowatt hours (kWh) that may be stored in the vehicle's battery.
   *
   * This parameter co-exists with **currentChargeInkWh** parameter.
   *
   * Minimum value has to be greater than or equal to **currentChargeInkWh**.
   *
   * Sensible Values : 85
   */
  maxChargeInkWh?: string;
  /**
   * Specifies the amount of power consumed for sustaining auxiliary systems, in kilowatts (kW).
   *
   * It can be used to specify consumption due to devices and systems such as AC systems, radio, heating, etc.
   *
   * Sensible Values : 1.7
   */
  auxiliaryPowerInkW?: string;
}

/** Contains response data for the getRouteDirections operation. */
export type RouteGetRouteDirectionsResponse = RouteDirectionsResponse;

/** Optional parameters. */
export interface RoutePostRouteDirectionsOptionalParams
  extends coreClient.OperationOptions {
  /** Specifies whether to return additional travel times using different types of traffic information (none, historic, live) as well as the default best-estimate travel time. */
  computeTravelTimeFor?: ComputeTravelTimeFor;
  /** Specifies which of the section types is reported in the route response. <br><br>For example if sectionType = pedestrian the sections which are suited for pedestrians only are returned. Multiple types can be used. The default sectionType refers to the travelMode input. By default travelMode is set to car */
  sectionType?: SectionType;
  /** The date and time of arrival at the destination point. It must be specified as a dateTime. When a time zone offset is not specified it will be assumed to be that of the destination point. The arriveAt value must be in the future. The arriveAt parameter cannot be used in conjunction with departAt, minDeviationDistance or minDeviationTime. */
  arriveAt?: Date;
  /** The date and time of departure from the origin point. Departure times apart from now must be specified as a dateTime. When a time zone offset is not specified, it will be assumed to be that of the origin point. The departAt value must be in the future in the date-time format (1996-12-19T16:39:57-08:00). */
  departAt?: Date;
  /** Weight per axle of the vehicle in kg. A value of 0 means that weight restrictions per axle are not considered. */
  vehicleAxleWeight?: number;
  /** Length of the vehicle in meters. A value of 0 means that length restrictions are not considered. */
  vehicleLength?: number;
  /** Height of the vehicle in meters. A value of 0 means that height restrictions are not considered. */
  vehicleHeight?: number;
  /** Width of the vehicle in meters. A value of 0 means that width restrictions are not considered. */
  vehicleWidth?: number;
  /**
   * Maximum speed of the vehicle in km/hour. The max speed in the vehicle profile is used to check whether a vehicle is allowed on motorways.
   *
   * * A value of 0 means that an appropriate value for the vehicle will be determined and applied during route planning.
   *
   * * A non-zero value may be overridden during route planning. For example, the current traffic flow is 60 km/hour. If the vehicle  maximum speed is set to 50 km/hour, the routing engine will consider 60 km/hour as this is the current situation.  If the maximum speed of the vehicle is provided as 80 km/hour but the current traffic flow is 60 km/hour, then routing engine will again use 60 km/hour.
   */
  vehicleMaxSpeed?: number;
  /**
   * Weight of the vehicle in kilograms.
   *
   * * It is mandatory if any of the *Efficiency parameters are set.
   *
   * * It must be strictly positive when used in the context of the Consumption Model. Weight restrictions are considered.
   *
   * * If no detailed **Consumption Model** is specified and the value of **vehicleWeight** is non-zero, then weight restrictions are considered.
   *
   * * In all other cases, this parameter is ignored.
   *
   * Sensible Values : for **Combustion Model** : 1600, for **Electric Model** : 1900
   */
  vehicleWeight?: number;
  /** Level of turns for thrilling route. This parameter can only be used in conjunction with `routeType`=thrilling. */
  windingness?: WindingnessLevel;
  /** Degree of hilliness for thrilling route. This parameter can only be used in conjunction with `routeType`=thrilling. */
  hilliness?: HillinessDegree;
  /** The mode of travel for the requested route. If not defined, default is 'car'. Note that the requested travelMode may not be available for the entire route. Where the requested travelMode is not available for a particular section, the travelMode element of the response for that section will be "other". Note that travel modes bus, motorcycle, taxi and van are BETA functionality. Full restriction data is not available in all areas. In **calculateReachableRange** requests, the values bicycle and pedestrian must not be used. */
  travelMode?: TravelMode;
  /** Specifies something that the route calculation should try to avoid when determining the route. Can be specified multiple times in one request, for example, '&avoid=motorways&avoid=tollRoads&avoid=ferries'. In calculateReachableRange requests, the value alreadyUsedRoads must not be used. */
  avoid?: RouteAvoidType[];
  /**
   * Possible values:
   *   * true - Do consider all available traffic information during routing
   *   * false - Ignore current traffic data during routing. Note that although the current traffic data is ignored
   *   during routing, the effect of historic traffic on effective road speeds is still incorporated.
   */
  traffic?: boolean;
  /** The type of route requested. */
  routeType?: RouteType;
  /** Types of cargo that may be classified as hazardous materials and restricted from some roads. Available vehicleLoadType values are US Hazmat classes 1 through 9, plus generic classifications for use in other countries. Values beginning with USHazmat are for US routing while otherHazmat should be used for all other countries. vehicleLoadType can be specified multiple times. This parameter is currently only considered for travelMode=truck. */
  vehicleLoadType?: VehicleLoadType;
  /** Number of desired alternative routes to be calculated. Default: 0, minimum: 0 and maximum: 5 */
  maxAlternatives?: number;
  /** Controls the optimality, with respect to the given planning criteria, of the calculated alternatives compared to the reference route. */
  alternativeType?: AlternativeRouteType;
  /** All alternative routes returned will follow the reference route (see section POST Requests) from the origin point of the calculateRoute request for at least this number of meters. Can only be used when reconstructing a route. The minDeviationDistance parameter cannot be used in conjunction with arriveAt */
  minDeviationDistance?: number;
  /**
   * All alternative routes returned will follow the reference route (see section POST Requests) from the origin point of the calculateRoute request for at least this number of seconds. Can only be used when reconstructing a route. The minDeviationTime parameter cannot be used in conjunction with arriveAt. Default value is 0. Setting )minDeviationTime_ to a value greater than zero has the following consequences:
   *   - The origin point of the _calculateRoute_ Request must be on
   *     (or very near) the input reference route.
   *     - If this is not the case, an error is returned.
   *     - However, the origin point does not need to be at the beginning
   *       of the input reference route (it can be thought of as the current
   *       vehicle position on the reference route).
   *   - The reference route, returned as the first route in the _calculateRoute_
   *     Response, will start at the origin point specified in the _calculateRoute_
   *     Request. The initial part of the input reference route up until the origin
   *     point will be excluded from the Response.
   *   - The values of _minDeviationDistance_ and _minDeviationTime_ determine
   *     how far alternative routes will be guaranteed to follow the reference
   *     route from the origin point onwards.
   *   - The route must use _departAt_.
   *   - The _vehicleHeading_ is ignored.
   */
  minDeviationTime?: number;
  /** If specified, guidance instructions will be returned. Note that the instructionsType parameter cannot be used in conjunction with routeRepresentation=none */
  instructionsType?: RouteInstructionsType;
  /** The language parameter determines the language of the guidance messages. It does not affect proper nouns (the names of streets, plazas, etc.) It has no effect when instructionsType=coded. Allowed values are (a subset of) the IETF language tags described */
  language?: string;
  /** Re-order the route waypoints using a fast heuristic algorithm to reduce the route length. Yields best results when used in conjunction with routeType _shortest_. Notice that origin and destination are excluded from the optimized waypoint indices. To include origin and destination in the response, please increase all the indices by 1 to account for the origin, and then add the destination as the final index. Possible values are true or false. True computes a better order if possible, but is not allowed to be used in conjunction with maxAlternatives value greater than 0 or in conjunction with circle waypoints. False will use the locations in the given order and not allowed to be used in conjunction with routeRepresentation _none_. */
  computeBestOrder?: boolean;
  /** Specifies the representation of the set of routes provided as response. This parameter value can only be used in conjunction with computeBestOrder=true. */
  routeRepresentation?: RouteRepresentation;
  /** The directional heading of the vehicle in degrees starting at true North and continuing in clockwise direction. North is 0 degrees, east is 90 degrees, south is 180 degrees, west is 270 degrees. Possible values 0-359 */
  vehicleHeading?: number;
  /** Specifies which data should be reported for diagnosis purposes. The only possible value is _effectiveSettings_. Reports the effective parameters or data used when calling the API. In the case of defaulted parameters the default will be reflected where the parameter was not specified by the caller. */
  report?: string;
  /** Vehicle is used for commercial purposes and thus may not be allowed to drive  on some roads. */
  vehicleCommercial?: boolean;
  /** Engine type of the vehicle. When a detailed Consumption Model is specified, it must be consistent with the value of **vehicleEngineType**. */
  vehicleEngineType?: VehicleEngineType;
  /**
   *
   * Specifies the speed-dependent component of consumption.
   *
   * Provided as an unordered list of colon-delimited speed & consumption-rate pairs. The list defines points on a consumption curve. Consumption rates for speeds not in the list are found as follows:
   *
   *  * by linear interpolation, if the given speed lies in between two speeds in the list
   *
   *  * by linear extrapolation otherwise, assuming a constant (ΔConsumption/ΔSpeed) determined by the nearest two points in the list
   *
   * The list must contain between 1 and 25 points (inclusive), and may not contain duplicate points for the same speed. If it only contains a single point, then the consumption rate of that point is used without further processing.
   *
   * Consumption specified for the largest speed must be greater than or equal to that of the penultimate largest speed. This ensures that extrapolation does not lead to negative consumption rates.
   *
   * Similarly, consumption values specified for the two smallest speeds in the list cannot lead to a negative consumption rate for any smaller speed.
   *
   * The valid range for the consumption values(expressed in l/100km) is between 0.01 and 100000.0.
   *
   * Sensible Values : 50,6.3:130,11.5
   *
   * **Note** : This parameter is required for **The Combustion Consumption Model**.
   */
  constantSpeedConsumptionInLitersPerHundredkm?: number;
  /**
   * Specifies the current supply of fuel in liters.
   *
   * Sensible Values : 55
   */
  currentFuelInLiters?: number;
  /**
   * Specifies the amount of fuel consumed for sustaining auxiliary systems of the vehicle, in liters per hour.
   *
   * It can be used to specify consumption due to devices and systems such as AC systems, radio, heating, etc.
   *
   * Sensible Values : 0.2
   */
  auxiliaryPowerInLitersPerHour?: number;
  /**
   * Specifies the amount of chemical energy stored in one liter of fuel in megajoules (MJ). It is used in conjunction with the ***Efficiency** parameters for conversions between saved or consumed energy and fuel. For example, energy density is 34.2 MJ/l for gasoline, and 35.8 MJ/l for Diesel fuel.
   *
   * This parameter is required if any ***Efficiency** parameter is set.
   *
   * Sensible Values : 34.2
   */
  fuelEnergyDensityInMJoulesPerLiter?: number;
  /**
   * Specifies the efficiency of converting chemical energy stored in fuel to kinetic energy when the vehicle accelerates _(i.e. KineticEnergyGained/ChemicalEnergyConsumed). ChemicalEnergyConsumed_ is obtained by converting consumed fuel to chemical energy using **fuelEnergyDensityInMJoulesPerLiter**.
   *
   * Must be paired with **decelerationEfficiency**.
   *
   * The range of values allowed are 0.0 to 1/**decelerationEfficiency**.
   *
   * Sensible Values : for **Combustion Model** : 0.33, for **Electric Model** : 0.66
   */
  accelerationEfficiency?: number;
  /**
   * Specifies the efficiency of converting kinetic energy to saved (not consumed) fuel when the vehicle decelerates _(i.e. ChemicalEnergySaved/KineticEnergyLost). ChemicalEnergySaved_ is obtained by converting saved (not consumed) fuel to energy using **fuelEnergyDensityInMJoulesPerLiter**.
   *
   * Must be paired with **accelerationEfficiency**.
   *
   * The range of values allowed are 0.0 to 1/**accelerationEfficiency**.
   *
   * Sensible Values : for **Combustion Model** : 0.83, for **Electric Model** : 0.91
   */
  decelerationEfficiency?: number;
  /**
   * Specifies the efficiency of converting chemical energy stored in fuel to potential energy when the vehicle gains elevation _(i.e. PotentialEnergyGained/ChemicalEnergyConsumed). ChemicalEnergyConsumed_ is obtained by converting consumed fuel to chemical energy using **fuelEnergyDensityInMJoulesPerLiter**.
   *
   * Must be paired with **downhillEfficiency**.
   *
   * The range of values allowed are 0.0 to 1/**downhillEfficiency**.
   *
   * Sensible Values : for **Combustion Model** : 0.27, for **Electric Model** : 0.74
   */
  uphillEfficiency?: number;
  /**
   * Specifies the efficiency of converting potential energy to saved (not consumed) fuel when the vehicle loses elevation _(i.e. ChemicalEnergySaved/PotentialEnergyLost). ChemicalEnergySaved_ is obtained by converting saved (not consumed) fuel to energy using **fuelEnergyDensityInMJoulesPerLiter**.
   *
   * Must be paired with **uphillEfficiency**.
   *
   * The range of values allowed are 0.0 to 1/**uphillEfficiency**.
   *
   * Sensible Values : for **Combustion Model** : 0.51, for **Electric Model** : 0.73
   */
  downhillEfficiency?: number;
  /**
   * Specifies the speed-dependent component of consumption.
   *
   * Provided as an unordered list of speed/consumption-rate pairs. The list defines points on a consumption curve. Consumption rates for speeds not in the list are found as follows:
   *
   * * by linear interpolation, if the given speed lies in between two speeds in the list
   *
   * * by linear extrapolation otherwise, assuming a constant (ΔConsumption/ΔSpeed) determined by the nearest two points in the list
   *
   * The list must contain between 1 and 25 points (inclusive), and may not contain duplicate points for the same speed. If it only contains a single point, then the consumption rate of that point is used without further processing.
   *
   * Consumption specified for the largest speed must be greater than or equal to that of the penultimate largest speed. This ensures that extrapolation does not lead to negative consumption rates.
   *
   * Similarly, consumption values specified for the two smallest speeds in the list cannot lead to a negative consumption rate for any smaller  speed.
   *
   * The valid range for the consumption values(expressed in kWh/100km) is between 0.01 and 100000.0.
   *
   * Sensible Values : 50,8.2:130,21.3
   *
   * This parameter is required for **Electric consumption model**.
   */
  constantSpeedConsumptionInkWhPerHundredkm?: string;
  /**
   * Specifies the current electric energy supply in kilowatt hours (kWh).
   *
   * This parameter co-exists with **maxChargeInkWh** parameter.
   *
   * The range of values allowed are 0.0 to **maxChargeInkWh**.
   *
   * Sensible Values : 43
   */
  currentChargeInkWh?: string;
  /**
   * Specifies the maximum electric energy supply in kilowatt hours (kWh) that may be stored in the vehicle's battery.
   *
   * This parameter co-exists with **currentChargeInkWh** parameter.
   *
   * Minimum value has to be greater than or equal to **currentChargeInkWh**.
   *
   * Sensible Values : 85
   */
  maxChargeInkWh?: string;
  /**
   * Specifies the amount of power consumed for sustaining auxiliary systems, in kilowatts (kW).
   *
   * It can be used to specify consumption due to devices and systems such as AC systems, radio, heating, etc.
   *
   * Sensible Values : 1.7
   */
  auxiliaryPowerInkW?: string;
}

/** Contains response data for the postRouteDirections operation. */
export type RoutePostRouteDirectionsResponse = RouteDirectionsResponse;

/** Optional parameters. */
export interface RouteGetRouteRangeOptionalParams
  extends coreClient.OperationOptions {
  /** The date and time of departure from the origin point. Departure times apart from now must be specified as a dateTime. When a time zone offset is not specified, it will be assumed to be that of the origin point. The departAt value must be in the future in the date-time format (1996-12-19T16:39:57-08:00). */
  departAt?: Date;
  /** Weight per axle of the vehicle in kg. A value of 0 means that weight restrictions per axle are not considered. */
  vehicleAxleWeight?: number;
  /** Length of the vehicle in meters. A value of 0 means that length restrictions are not considered. */
  vehicleLength?: number;
  /** Height of the vehicle in meters. A value of 0 means that height restrictions are not considered. */
  vehicleHeight?: number;
  /** Width of the vehicle in meters. A value of 0 means that width restrictions are not considered. */
  vehicleWidth?: number;
  /**
   * Maximum speed of the vehicle in km/hour. The max speed in the vehicle profile is used to check whether a vehicle is allowed on motorways.
   *
   * * A value of 0 means that an appropriate value for the vehicle will be determined and applied during route planning.
   *
   * * A non-zero value may be overridden during route planning. For example, the current traffic flow is 60 km/hour. If the vehicle  maximum speed is set to 50 km/hour, the routing engine will consider 60 km/hour as this is the current situation.  If the maximum speed of the vehicle is provided as 80 km/hour but the current traffic flow is 60 km/hour, then routing engine will again use 60 km/hour.
   */
  vehicleMaxSpeed?: number;
  /**
   * Weight of the vehicle in kilograms.
   *
   * * It is mandatory if any of the *Efficiency parameters are set.
   *
   * * It must be strictly positive when used in the context of the Consumption Model. Weight restrictions are considered.
   *
   * * If no detailed **Consumption Model** is specified and the value of **vehicleWeight** is non-zero, then weight restrictions are considered.
   *
   * * In all other cases, this parameter is ignored.
   *
   * Sensible Values : for **Combustion Model** : 1600, for **Electric Model** : 1900
   */
  vehicleWeight?: number;
  /** Level of turns for thrilling route. This parameter can only be used in conjunction with `routeType`=thrilling. */
  windingness?: WindingnessLevel;
  /** Degree of hilliness for thrilling route. This parameter can only be used in conjunction with `routeType`=thrilling. */
  hilliness?: HillinessDegree;
  /** The mode of travel for the requested route. If not defined, default is 'car'. Note that the requested travelMode may not be available for the entire route. Where the requested travelMode is not available for a particular section, the travelMode element of the response for that section will be "other". Note that travel modes bus, motorcycle, taxi and van are BETA functionality. Full restriction data is not available in all areas. In **calculateReachableRange** requests, the values bicycle and pedestrian must not be used. */
  travelMode?: TravelMode;
  /** Specifies something that the route calculation should try to avoid when determining the route. Can be specified multiple times in one request, for example, '&avoid=motorways&avoid=tollRoads&avoid=ferries'. In calculateReachableRange requests, the value alreadyUsedRoads must not be used. */
  avoid?: RouteAvoidType[];
  /**
   * Possible values:
   *   * true - Do consider all available traffic information during routing
   *   * false - Ignore current traffic data during routing. Note that although the current traffic data is ignored
   *   during routing, the effect of historic traffic on effective road speeds is still incorporated.
   */
  traffic?: boolean;
  /** The type of route requested. */
  routeType?: RouteType;
  /** Types of cargo that may be classified as hazardous materials and restricted from some roads. Available vehicleLoadType values are US Hazmat classes 1 through 9, plus generic classifications for use in other countries. Values beginning with USHazmat are for US routing while otherHazmat should be used for all other countries. vehicleLoadType can be specified multiple times. This parameter is currently only considered for travelMode=truck. */
  vehicleLoadType?: VehicleLoadType;
  /** Vehicle is used for commercial purposes and thus may not be allowed to drive  on some roads. */
  vehicleCommercial?: boolean;
  /** Engine type of the vehicle. When a detailed Consumption Model is specified, it must be consistent with the value of **vehicleEngineType**. */
  vehicleEngineType?: VehicleEngineType;
  /**
   *
   * Specifies the speed-dependent component of consumption.
   *
   * Provided as an unordered list of colon-delimited speed & consumption-rate pairs. The list defines points on a consumption curve. Consumption rates for speeds not in the list are found as follows:
   *
   *  * by linear interpolation, if the given speed lies in between two speeds in the list
   *
   *  * by linear extrapolation otherwise, assuming a constant (ΔConsumption/ΔSpeed) determined by the nearest two points in the list
   *
   * The list must contain between 1 and 25 points (inclusive), and may not contain duplicate points for the same speed. If it only contains a single point, then the consumption rate of that point is used without further processing.
   *
   * Consumption specified for the largest speed must be greater than or equal to that of the penultimate largest speed. This ensures that extrapolation does not lead to negative consumption rates.
   *
   * Similarly, consumption values specified for the two smallest speeds in the list cannot lead to a negative consumption rate for any smaller speed.
   *
   * The valid range for the consumption values(expressed in l/100km) is between 0.01 and 100000.0.
   *
   * Sensible Values : 50,6.3:130,11.5
   *
   * **Note** : This parameter is required for **The Combustion Consumption Model**.
   */
  constantSpeedConsumptionInLitersPerHundredkm?: number;
  /**
   * Specifies the current supply of fuel in liters.
   *
   * Sensible Values : 55
   */
  currentFuelInLiters?: number;
  /**
   * Specifies the amount of fuel consumed for sustaining auxiliary systems of the vehicle, in liters per hour.
   *
   * It can be used to specify consumption due to devices and systems such as AC systems, radio, heating, etc.
   *
   * Sensible Values : 0.2
   */
  auxiliaryPowerInLitersPerHour?: number;
  /**
   * Specifies the amount of chemical energy stored in one liter of fuel in megajoules (MJ). It is used in conjunction with the ***Efficiency** parameters for conversions between saved or consumed energy and fuel. For example, energy density is 34.2 MJ/l for gasoline, and 35.8 MJ/l for Diesel fuel.
   *
   * This parameter is required if any ***Efficiency** parameter is set.
   *
   * Sensible Values : 34.2
   */
  fuelEnergyDensityInMJoulesPerLiter?: number;
  /**
   * Specifies the efficiency of converting chemical energy stored in fuel to kinetic energy when the vehicle accelerates _(i.e. KineticEnergyGained/ChemicalEnergyConsumed). ChemicalEnergyConsumed_ is obtained by converting consumed fuel to chemical energy using **fuelEnergyDensityInMJoulesPerLiter**.
   *
   * Must be paired with **decelerationEfficiency**.
   *
   * The range of values allowed are 0.0 to 1/**decelerationEfficiency**.
   *
   * Sensible Values : for **Combustion Model** : 0.33, for **Electric Model** : 0.66
   */
  accelerationEfficiency?: number;
  /**
   * Specifies the efficiency of converting kinetic energy to saved (not consumed) fuel when the vehicle decelerates _(i.e. ChemicalEnergySaved/KineticEnergyLost). ChemicalEnergySaved_ is obtained by converting saved (not consumed) fuel to energy using **fuelEnergyDensityInMJoulesPerLiter**.
   *
   * Must be paired with **accelerationEfficiency**.
   *
   * The range of values allowed are 0.0 to 1/**accelerationEfficiency**.
   *
   * Sensible Values : for **Combustion Model** : 0.83, for **Electric Model** : 0.91
   */
  decelerationEfficiency?: number;
  /**
   * Specifies the efficiency of converting chemical energy stored in fuel to potential energy when the vehicle gains elevation _(i.e. PotentialEnergyGained/ChemicalEnergyConsumed). ChemicalEnergyConsumed_ is obtained by converting consumed fuel to chemical energy using **fuelEnergyDensityInMJoulesPerLiter**.
   *
   * Must be paired with **downhillEfficiency**.
   *
   * The range of values allowed are 0.0 to 1/**downhillEfficiency**.
   *
   * Sensible Values : for **Combustion Model** : 0.27, for **Electric Model** : 0.74
   */
  uphillEfficiency?: number;
  /**
   * Specifies the efficiency of converting potential energy to saved (not consumed) fuel when the vehicle loses elevation _(i.e. ChemicalEnergySaved/PotentialEnergyLost). ChemicalEnergySaved_ is obtained by converting saved (not consumed) fuel to energy using **fuelEnergyDensityInMJoulesPerLiter**.
   *
   * Must be paired with **uphillEfficiency**.
   *
   * The range of values allowed are 0.0 to 1/**uphillEfficiency**.
   *
   * Sensible Values : for **Combustion Model** : 0.51, for **Electric Model** : 0.73
   */
  downhillEfficiency?: number;
  /**
   * Specifies the speed-dependent component of consumption.
   *
   * Provided as an unordered list of speed/consumption-rate pairs. The list defines points on a consumption curve. Consumption rates for speeds not in the list are found as follows:
   *
   * * by linear interpolation, if the given speed lies in between two speeds in the list
   *
   * * by linear extrapolation otherwise, assuming a constant (ΔConsumption/ΔSpeed) determined by the nearest two points in the list
   *
   * The list must contain between 1 and 25 points (inclusive), and may not contain duplicate points for the same speed. If it only contains a single point, then the consumption rate of that point is used without further processing.
   *
   * Consumption specified for the largest speed must be greater than or equal to that of the penultimate largest speed. This ensures that extrapolation does not lead to negative consumption rates.
   *
   * Similarly, consumption values specified for the two smallest speeds in the list cannot lead to a negative consumption rate for any smaller  speed.
   *
   * The valid range for the consumption values(expressed in kWh/100km) is between 0.01 and 100000.0.
   *
   * Sensible Values : 50,8.2:130,21.3
   *
   * This parameter is required for **Electric consumption model**.
   */
  constantSpeedConsumptionInkWhPerHundredkm?: string;
  /**
   * Specifies the current electric energy supply in kilowatt hours (kWh).
   *
   * This parameter co-exists with **maxChargeInkWh** parameter.
   *
   * The range of values allowed are 0.0 to **maxChargeInkWh**.
   *
   * Sensible Values : 43
   */
  currentChargeInkWh?: string;
  /**
   * Specifies the maximum electric energy supply in kilowatt hours (kWh) that may be stored in the vehicle's battery.
   *
   * This parameter co-exists with **currentChargeInkWh** parameter.
   *
   * Minimum value has to be greater than or equal to **currentChargeInkWh**.
   *
   * Sensible Values : 85
   */
  maxChargeInkWh?: string;
  /**
   * Specifies the amount of power consumed for sustaining auxiliary systems, in kilowatts (kW).
   *
   * It can be used to specify consumption due to devices and systems such as AC systems, radio, heating, etc.
   *
   * Sensible Values : 1.7
   */
  auxiliaryPowerInkW?: string;
  /** Fuel budget in liters that determines maximal range which can be travelled using the specified Combustion Consumption Model.<br> When fuelBudgetInLiters is used, it is mandatory to specify a detailed  Combustion Consumption Model.<br> Exactly one budget (fuelBudgetInLiters, energyBudgetInkWh, timeBudgetInSec, or distanceBudgetInMeters) must be used. */
  fuelBudgetInLiters?: number;
  /** Electric energy budget in kilowatt hours (kWh) that determines maximal range which can be travelled using the specified Electric Consumption Model.<br> When energyBudgetInkWh is used, it is mandatory to specify a detailed Electric Consumption Model.<br> Exactly one budget (fuelBudgetInLiters, energyBudgetInkWh, timeBudgetInSec, or distanceBudgetInMeters) must be used. */
  energyBudgetInkWh?: number;
  /** Time budget in seconds that determines maximal range which can be travelled using driving time. The Consumption Model will only affect the range when routeType is eco.<br> Exactly one budget (fuelBudgetInLiters, energyBudgetInkWh, timeBudgetInSec, or distanceBudgetInMeters) must be used. */
  timeBudgetInSec?: number;
  /** Distance budget in meters that determines maximal range which can be travelled using driving distance.  The Consumption Model will only affect the range when routeType is eco.<br> Exactly one budget (fuelBudgetInLiters, energyBudgetInkWh, timeBudgetInSec, or distanceBudgetInMeters) must be used. */
  distanceBudgetInMeters?: number;
}

/** Contains response data for the getRouteRange operation. */
export type RouteGetRouteRangeResponse = GetRouteRangeResponse;

/** Optional parameters. */
export interface RoutePostRouteDirectionsBatchOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Contains response data for the postRouteDirectionsBatch operation. */
export type RoutePostRouteDirectionsBatchResponse = RouteDirectionsBatchResponse;

/** Optional parameters. */
export interface RoutePostRouteDirectionsBatchSyncOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the postRouteDirectionsBatchSync operation. */
export type RoutePostRouteDirectionsBatchSyncResponse = RouteDirectionsBatchResponse;

/** Optional parameters. */
export interface RouteClientOptionalParams
  extends coreClient.ServiceClientOptions {
  /** This parameter specifies where the Azure Maps Creator resource is located.  Valid values are us and eu. */
  geography?: Geography;
  /** Specifies which account is intended for usage in conjunction with the Azure AD security model.  It represents a unique ID for the Azure Maps account and can be retrieved from the Azure Maps management  plane Account API. To use Azure AD security in Azure Maps see the following [articles](https://aka.ms/amauthdetails) for guidance. */
  xMsClientId?: string;
  /** Api Version */
  apiVersion?: string;
  /** Overrides client endpoint. */
  endpoint?: string;
}
