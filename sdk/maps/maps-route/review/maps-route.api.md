## API Report File for "@azure/maps-route"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as coreAuth from '@azure/core-auth';
import * as coreClient from '@azure/core-client';
import { PollerLike } from '@azure/core-lro';
import { PollOperationState } from '@azure/core-lro';

// @public
export type AlternativeRouteType = string;

// @public
export interface BatchItem {
    readonly statusCode?: number;
}

// @public
export interface BatchRequestBody {
    batchItems?: BatchRequestBodyBatchItemsItem[];
}

// @public
export interface BatchRequestBodyBatchItemsItem {
    query?: string;
}

// @public
export interface BatchResponse {
    readonly summary?: BatchResponseSummary;
}

// @public
export interface BatchResponseSummary {
    readonly successfulRequests?: number;
    readonly totalRequests?: number;
}

// @public
export type ComputeTravelTimeFor = string;

// @public
export interface CoordinatesPair {
    latitude?: number;
    longitude?: number;
}

// @public
export type DrivingSide = string;

// @public
export interface ErrorAdditionalInfo {
    readonly info?: Record<string, unknown>;
    readonly type?: string;
}

// @public
export interface ErrorDetail {
    readonly additionalInfo?: ErrorAdditionalInfo[];
    readonly code?: string;
    readonly details?: ErrorDetail[];
    readonly message?: string;
    readonly target?: string;
}

// @public
export interface ErrorResponse {
    error?: ErrorDetail;
}

// @public
export type GeographicResourceLocation = string;

// @public
export type Geography = string;

// @public
export type GeoJsonFeature = GeoJsonObject & GeoJsonFeatureData & {
    type: "Feature";
};

// @public
export type GeoJsonFeatureCollection = GeoJsonObject & GeoJsonFeatureCollectionData & {
    type: "FeatureCollection";
};

// @public (undocumented)
export interface GeoJsonFeatureCollectionData {
    features: GeoJsonFeature[];
}

// @public (undocumented)
export interface GeoJsonFeatureData {
    featureType?: string;
    geometry: GeoJsonGeometryUnion;
    id?: string;
    properties?: Record<string, unknown>;
}

// @public
export type GeoJsonGeometry = GeoJsonObject & {
    type: "GeoJsonGeometry" | "MultiPoint" | "MultiPolygon" | "Point" | "LineString" | "MultiLineString" | "Polygon" | "GeometryCollection";
};

// @public
export type GeoJsonGeometryCollection = GeoJsonGeometry & GeoJsonGeometryCollectionData & {};

// @public (undocumented)
export interface GeoJsonGeometryCollectionData {
    geometries: GeoJsonGeometryUnion[];
}

// @public (undocumented)
export type GeoJsonGeometryUnion = GeoJsonGeometry | GeoJsonMultiPoint | GeoJsonMultiPolygon | GeoJsonPoint | GeoJsonLineString | GeoJsonMultiLineString | GeoJsonPolygon | GeoJsonGeometryCollection;

// @public
export type GeoJsonLineString = GeoJsonGeometry & GeoJsonLineStringData & {};

// @public (undocumented)
export interface GeoJsonLineStringData {
    coordinates: number[][];
}

// @public
export type GeoJsonMultiLineString = GeoJsonGeometry & GeoJsonMultiLineStringData & {};

// @public (undocumented)
export interface GeoJsonMultiLineStringData {
    coordinates: number[][][];
}

// @public
export type GeoJsonMultiPoint = GeoJsonGeometry & GeoJsonMultiPointData & {};

// @public
export interface GeoJsonMultiPointData {
    coordinates: number[][];
}

// @public
export type GeoJsonMultiPolygon = GeoJsonGeometry & GeoJsonMultiPolygonData & {};

// @public (undocumented)
export interface GeoJsonMultiPolygonData {
    coordinates: number[][][][];
}

// @public
export interface GeoJsonObject {
    type: "GeoJsonGeometry" | "MultiPoint" | "MultiPolygon" | "Point" | "LineString" | "MultiLineString" | "Polygon" | "GeometryCollection" | "Feature" | "FeatureCollection";
}

// @public
export type GeoJsonObjectType = string;

// @public (undocumented)
export type GeoJsonObjectUnion = GeoJsonObject | GeoJsonGeometryUnion | GeoJsonFeature | GeoJsonFeatureCollection;

// @public
export type GeoJsonPoint = GeoJsonGeometry & GeoJsonPointData & {};

// @public
export interface GeoJsonPointData {
    coordinates: number[];
}

// @public
export type GeoJsonPolygon = GeoJsonGeometry & GeoJsonPolygonData & {};

// @public (undocumented)
export interface GeoJsonPolygonData {
    coordinates: number[][][];
}

// @public
export interface GetRouteRangeResponse {
    readonly formatVersion?: string;
    reachableRange?: RouteRange;
    report?: RouteResponseReport;
}

// @public
export type GuidanceInstructionType = string;

// @public
export type GuidanceManeuver = string;

// @public
export type HillinessDegree = string;

// @public
export type JunctionType = string;

// @public
export const enum KnownAlternativeRouteType {
    AnyRoute = "anyRoute",
    BetterRoute = "betterRoute"
}

// @public
export const enum KnownComputeTravelTimeFor {
    All = "all",
    None = "none"
}

// @public
export const enum KnownDrivingSide {
    Left = "LEFT",
    Right = "RIGHT"
}

// @public
export const enum KnownGeographicResourceLocation {
    Eu = "eu",
    Us = "us"
}

// @public
export const enum KnownGeography {
    // (undocumented)
    Eu = "eu",
    // (undocumented)
    Us = "us"
}

// @public
export const enum KnownGeoJsonObjectType {
    GeoJsonFeature = "Feature",
    GeoJsonFeatureCollection = "FeatureCollection",
    GeoJsonGeometryCollection = "GeometryCollection",
    GeoJsonLineString = "LineString",
    GeoJsonMultiLineString = "MultiLineString",
    GeoJsonMultiPoint = "MultiPoint",
    GeoJsonMultiPolygon = "MultiPolygon",
    GeoJsonPoint = "Point",
    GeoJsonPolygon = "Polygon"
}

// @public
export const enum KnownGuidanceInstructionType {
    DirectionInfo = "DIRECTION_INFO",
    LocationArrival = "LOCATION_ARRIVAL",
    LocationDeparture = "LOCATION_DEPARTURE",
    LocationWaypoint = "LOCATION_WAYPOINT",
    RoadChange = "ROAD_CHANGE",
    Turn = "TURN"
}

// @public
export const enum KnownGuidanceManeuver {
    Arrive = "ARRIVE",
    ArriveLeft = "ARRIVE_LEFT",
    ArriveRight = "ARRIVE_RIGHT",
    BearLeft = "BEAR_LEFT",
    BearRight = "BEAR_RIGHT",
    Depart = "DEPART",
    EnterFreeway = "ENTER_FREEWAY",
    EnterHighway = "ENTER_HIGHWAY",
    EnterMotorway = "ENTER_MOTORWAY",
    EntranceRamp = "ENTRANCE_RAMP",
    Follow = "FOLLOW",
    KeepLeft = "KEEP_LEFT",
    KeepRight = "KEEP_RIGHT",
    MakeUturn = "MAKE_UTURN",
    MotorwayExitLeft = "MOTORWAY_EXIT_LEFT",
    MotorwayExitRight = "MOTORWAY_EXIT_RIGHT",
    RoundaboutBack = "ROUNDABOUT_BACK",
    RoundaboutCross = "ROUNDABOUT_CROSS",
    RoundaboutLeft = "ROUNDABOUT_LEFT",
    RoundaboutRight = "ROUNDABOUT_RIGHT",
    SharpLeft = "SHARP_LEFT",
    SharpRight = "SHARP_RIGHT",
    Straight = "STRAIGHT",
    SwitchMainRoad = "SWITCH_MAIN_ROAD",
    SwitchParallelRoad = "SWITCH_PARALLEL_ROAD",
    TakeExit = "TAKE_EXIT",
    TakeFerry = "TAKE_FERRY",
    TRYMakeUturn = "TRY_MAKE_UTURN",
    TurnLeft = "TURN_LEFT",
    TurnRight = "TURN_RIGHT",
    WaypointLeft = "WAYPOINT_LEFT",
    WaypointReached = "WAYPOINT_REACHED",
    WaypointRight = "WAYPOINT_RIGHT"
}

// @public
export const enum KnownHillinessDegree {
    High = "high",
    Low = "low",
    Normal = "normal"
}

// @public
export const enum KnownJunctionType {
    Bifurcation = "BIFURCATION",
    Regular = "REGULAR",
    Roundabout = "ROUNDABOUT"
}

// @public
export const enum KnownMagnitudeOfDelay {
    Four = "4",
    One = "1",
    Three = "3",
    Two = "2",
    Zero = "0"
}

// @public
export const enum KnownResponseFormat {
    Json = "json"
}

// @public
export const enum KnownRouteAvoidType {
    AlreadyUsedRoads = "alreadyUsedRoads",
    BorderCrossings = "borderCrossings",
    Carpools = "carpools",
    Ferries = "ferries",
    Motorways = "motorways",
    TollRoads = "tollRoads",
    UnpavedRoads = "unpavedRoads"
}

// @public
export const enum KnownRouteInstructionsType {
    Coded = "coded",
    Tagged = "tagged",
    Text = "text"
}

// @public
export const enum KnownRouteRepresentation {
    None = "none",
    Polyline = "polyline",
    SummaryOnly = "summaryOnly"
}

// @public
export const enum KnownRouteType {
    Eco = "eco",
    Fastest = "fastest",
    Shortest = "shortest",
    Thrilling = "thrilling"
}

// @public
export const enum KnownSectionType {
    CarTrain = "carTrain",
    Country = "country",
    Ferry = "ferry",
    Motorway = "motorway",
    Pedestrian = "pedestrian",
    TollRoad = "tollRoad",
    TollVignette = "tollVignette",
    Traffic = "traffic",
    TravelMode = "travelMode",
    Tunnel = "tunnel"
}

// @public
export const enum KnownTextFormat {
    Json = "json",
    Xml = "xml"
}

// @public
export const enum KnownTravelMode {
    Bicycle = "bicycle",
    Bus = "bus",
    Car = "car",
    Motorcycle = "motorcycle",
    Pedestrian = "pedestrian",
    Taxi = "taxi",
    Truck = "truck",
    Van = "van"
}

// @public
export const enum KnownVehicleEngineType {
    Combustion = "combustion",
    Electric = "electric"
}

// @public
export const enum KnownVehicleLoadType {
    OtherHazmatExplosive = "otherHazmatExplosive",
    OtherHazmatGeneral = "otherHazmatGeneral",
    OtherHazmatHarmfulToWater = "otherHazmatHarmfulToWater",
    USHazmatClass1 = "USHazmatClass1",
    USHazmatClass2 = "USHazmatClass2",
    USHazmatClass3 = "USHazmatClass3",
    USHazmatClass4 = "USHazmatClass4",
    USHazmatClass5 = "USHazmatClass5",
    USHazmatClass6 = "USHazmatClass6",
    USHazmatClass7 = "USHazmatClass7",
    USHazmatClass8 = "USHazmatClass8",
    USHazmatClass9 = "USHazmatClass9"
}

// @public
export const enum KnownWindingnessLevel {
    High = "high",
    Low = "low",
    Normal = "normal"
}

// @public
export type MagnitudeOfDelay = string;

// @public
export interface PostRouteDirectionsRequestBody {
    allowVignette?: string[];
    avoidAreas?: GeoJsonMultiPolygon;
    avoidVignette?: string[];
    supportingPoints?: Record<string, unknown>;
}

// @public
export interface PostRouteMatrixRequestBody {
    destinations?: GeoJsonMultiPoint;
    origins?: GeoJsonMultiPoint;
}

// @public
export type ResponseFormat = string;

// @public
export interface Route {
    beginPostRouteDirectionsBatch(format: ResponseFormat, postRouteDirectionsBatchRequestBody: BatchRequestBody, options?: RoutePostRouteDirectionsBatchOptionalParams): Promise<PollerLike<PollOperationState<RoutePostRouteDirectionsBatchResponse>, RoutePostRouteDirectionsBatchResponse>>;
    beginPostRouteDirectionsBatchAndWait(format: ResponseFormat, postRouteDirectionsBatchRequestBody: BatchRequestBody, options?: RoutePostRouteDirectionsBatchOptionalParams): Promise<RoutePostRouteDirectionsBatchResponse>;
    beginPostRouteMatrix(format: ResponseFormat, postRouteMatrixRequestBody: PostRouteMatrixRequestBody, options?: RoutePostRouteMatrixOptionalParams): Promise<PollerLike<PollOperationState<RoutePostRouteMatrixResponse>, RoutePostRouteMatrixResponse>>;
    beginPostRouteMatrixAndWait(format: ResponseFormat, postRouteMatrixRequestBody: PostRouteMatrixRequestBody, options?: RoutePostRouteMatrixOptionalParams): Promise<RoutePostRouteMatrixResponse>;
    getRouteDirections(format: TextFormat, query: string, options?: RouteGetRouteDirectionsOptionalParams): Promise<RouteGetRouteDirectionsResponse>;
    getRouteRange(format: TextFormat, query: string, options?: RouteGetRouteRangeOptionalParams): Promise<RouteGetRouteRangeResponse>;
    postRouteDirections(format: TextFormat, query: string, postRouteDirectionsRequestBody: PostRouteDirectionsRequestBody, options?: RoutePostRouteDirectionsOptionalParams): Promise<RoutePostRouteDirectionsResponse>;
    postRouteDirectionsBatchSync(format: ResponseFormat, postRouteDirectionsBatchRequestBody: BatchRequestBody, options?: RoutePostRouteDirectionsBatchSyncOptionalParams): Promise<RoutePostRouteDirectionsBatchSyncResponse>;
    postRouteMatrixSync(format: ResponseFormat, postRouteMatrixRequestBody: PostRouteMatrixRequestBody, options?: RoutePostRouteMatrixSyncOptionalParams): Promise<RoutePostRouteMatrixSyncResponse>;
}

// @public
export type RouteAvoidType = string;

// @public (undocumented)
export class RouteClient extends RouteClientContext {
    constructor(credentials: coreAuth.TokenCredential, options?: RouteClientOptionalParams);
    // (undocumented)
    route: Route;
}

// @public (undocumented)
export class RouteClientContext extends coreClient.ServiceClient {
    constructor(credentials: coreAuth.TokenCredential, options?: RouteClientOptionalParams);
    // (undocumented)
    apiVersion: string;
    // (undocumented)
    geography: Geography;
    // (undocumented)
    xMsClientId?: string;
}

// @public
export interface RouteClientOptionalParams extends coreClient.ServiceClientOptions {
    apiVersion?: string;
    endpoint?: string;
    geography?: Geography;
    xMsClientId?: string;
}

// @public
export type RouteDirectionsBatchItem = BatchItem & {
    readonly response?: RouteDirectionsBatchItemResponse;
};

// @public
export type RouteDirectionsBatchItemResponse = RouteDirectionsResponse & ErrorResponse & {};

// @public
export type RouteDirectionsBatchResponse = BatchResponse & {
    readonly batchItems?: RouteDirectionsBatchItem[];
};

// @public
export interface RouteDirectionsResponse {
    readonly formatVersion?: string;
    readonly optimizedWaypoints?: RouteOptimizedWaypoint[];
    report?: RouteResponseReport;
    readonly routes?: RouteDirectionsResult[];
}

// @public (undocumented)
export interface RouteDirectionsResult {
    readonly guidance?: RouteResultGuidance;
    readonly legs?: RouteResultLeg[];
    readonly sections?: RouteResultSection[];
    readonly summary?: RouteDirectionsSummary;
}

// @public
export interface RouteDirectionsSummary {
    readonly arrivalTime?: string;
    readonly departureTime?: string;
    readonly lengthInMeters?: number;
    readonly trafficDelayInSeconds?: number;
    readonly travelTimeInSeconds?: number;
}

// @public
export interface RouteGetRouteDirectionsOptionalParams extends coreClient.OperationOptions {
    accelerationEfficiency?: number;
    alternativeType?: AlternativeRouteType;
    arriveAt?: Date;
    auxiliaryPowerInkW?: string;
    auxiliaryPowerInLitersPerHour?: number;
    avoid?: RouteAvoidType[];
    computeBestOrder?: boolean;
    computeTravelTimeFor?: ComputeTravelTimeFor;
    constantSpeedConsumptionInkWhPerHundredkm?: string;
    constantSpeedConsumptionInLitersPerHundredkm?: number;
    currentChargeInkWh?: string;
    currentFuelInLiters?: number;
    decelerationEfficiency?: number;
    departAt?: Date;
    downhillEfficiency?: number;
    fuelEnergyDensityInMJoulesPerLiter?: number;
    hilliness?: HillinessDegree;
    instructionsType?: RouteInstructionsType;
    language?: string;
    maxAlternatives?: number;
    maxChargeInkWh?: string;
    minDeviationDistance?: number;
    minDeviationTime?: number;
    report?: string;
    routeRepresentation?: RouteRepresentation;
    routeType?: RouteType;
    sectionType?: SectionType;
    traffic?: boolean;
    travelMode?: TravelMode;
    uphillEfficiency?: number;
    vehicleAxleWeight?: number;
    vehicleCommercial?: boolean;
    vehicleEngineType?: VehicleEngineType;
    vehicleHeading?: number;
    vehicleHeight?: number;
    vehicleLength?: number;
    vehicleLoadType?: VehicleLoadType;
    vehicleMaxSpeed?: number;
    vehicleWeight?: number;
    vehicleWidth?: number;
    windingness?: WindingnessLevel;
}

// @public
export type RouteGetRouteDirectionsResponse = RouteDirectionsResponse;

// @public
export interface RouteGetRouteRangeOptionalParams extends coreClient.OperationOptions {
    accelerationEfficiency?: number;
    auxiliaryPowerInkW?: string;
    auxiliaryPowerInLitersPerHour?: number;
    avoid?: RouteAvoidType[];
    constantSpeedConsumptionInkWhPerHundredkm?: string;
    constantSpeedConsumptionInLitersPerHundredkm?: number;
    currentChargeInkWh?: string;
    currentFuelInLiters?: number;
    decelerationEfficiency?: number;
    departAt?: Date;
    distanceBudgetInMeters?: number;
    downhillEfficiency?: number;
    energyBudgetInkWh?: number;
    fuelBudgetInLiters?: number;
    fuelEnergyDensityInMJoulesPerLiter?: number;
    hilliness?: HillinessDegree;
    maxChargeInkWh?: string;
    routeType?: RouteType;
    timeBudgetInSec?: number;
    traffic?: boolean;
    travelMode?: TravelMode;
    uphillEfficiency?: number;
    vehicleAxleWeight?: number;
    vehicleCommercial?: boolean;
    vehicleEngineType?: VehicleEngineType;
    vehicleHeight?: number;
    vehicleLength?: number;
    vehicleLoadType?: VehicleLoadType;
    vehicleMaxSpeed?: number;
    vehicleWeight?: number;
    vehicleWidth?: number;
    windingness?: WindingnessLevel;
}

// @public
export type RouteGetRouteRangeResponse = GetRouteRangeResponse;

// @public
export type RouteInstructionsType = string;

// @public
export interface RouteMatrixResponse {
    readonly formatVersion?: string;
    readonly matrix?: RouteMatrixResult[][];
    readonly summary?: RouteMatrixSummary;
}

// @public
export interface RouteMatrixResult {
    readonly response?: RouteMatrixResultResponse;
    readonly statusCode?: number;
}

// @public
export interface RouteMatrixResultResponse {
    readonly routeSummary?: RouteResultLegSummary;
}

// @public
export interface RouteMatrixSummary {
    readonly successfulRoutes?: number;
    readonly totalRoutes?: number;
}

// @public
export interface RouteOptimizedWaypoint {
    readonly optimizedIndex?: number;
    readonly providedIndex?: number;
}

// @public
export interface RoutePostRouteDirectionsBatchHeaders {
    location?: string;
}

// @public
export interface RoutePostRouteDirectionsBatchOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type RoutePostRouteDirectionsBatchResponse = RouteDirectionsBatchResponse;

// @public
export interface RoutePostRouteDirectionsBatchSyncOptionalParams extends coreClient.OperationOptions {
}

// @public
export type RoutePostRouteDirectionsBatchSyncResponse = RouteDirectionsBatchResponse;

// @public
export interface RoutePostRouteDirectionsOptionalParams extends coreClient.OperationOptions {
    accelerationEfficiency?: number;
    alternativeType?: AlternativeRouteType;
    arriveAt?: Date;
    auxiliaryPowerInkW?: string;
    auxiliaryPowerInLitersPerHour?: number;
    avoid?: RouteAvoidType[];
    computeBestOrder?: boolean;
    computeTravelTimeFor?: ComputeTravelTimeFor;
    constantSpeedConsumptionInkWhPerHundredkm?: string;
    constantSpeedConsumptionInLitersPerHundredkm?: number;
    currentChargeInkWh?: string;
    currentFuelInLiters?: number;
    decelerationEfficiency?: number;
    departAt?: Date;
    downhillEfficiency?: number;
    fuelEnergyDensityInMJoulesPerLiter?: number;
    hilliness?: HillinessDegree;
    instructionsType?: RouteInstructionsType;
    language?: string;
    maxAlternatives?: number;
    maxChargeInkWh?: string;
    minDeviationDistance?: number;
    minDeviationTime?: number;
    report?: string;
    routeRepresentation?: RouteRepresentation;
    routeType?: RouteType;
    sectionType?: SectionType;
    traffic?: boolean;
    travelMode?: TravelMode;
    uphillEfficiency?: number;
    vehicleAxleWeight?: number;
    vehicleCommercial?: boolean;
    vehicleEngineType?: VehicleEngineType;
    vehicleHeading?: number;
    vehicleHeight?: number;
    vehicleLength?: number;
    vehicleLoadType?: VehicleLoadType;
    vehicleMaxSpeed?: number;
    vehicleWeight?: number;
    vehicleWidth?: number;
    windingness?: WindingnessLevel;
}

// @public
export type RoutePostRouteDirectionsResponse = RouteDirectionsResponse;

// @public
export interface RoutePostRouteMatrixHeaders {
    location?: string;
}

// @public
export interface RoutePostRouteMatrixOptionalParams extends coreClient.OperationOptions {
    arriveAt?: Date;
    avoid?: RouteAvoidType[];
    computeTravelTimeFor?: ComputeTravelTimeFor;
    departAt?: Date;
    hilliness?: HillinessDegree;
    resumeFrom?: string;
    routeType?: RouteType;
    sectionType?: SectionType;
    traffic?: boolean;
    travelMode?: TravelMode;
    updateIntervalInMs?: number;
    vehicleAxleWeight?: number;
    vehicleHeight?: number;
    vehicleLength?: number;
    vehicleLoadType?: VehicleLoadType;
    vehicleMaxSpeed?: number;
    vehicleWeight?: number;
    vehicleWidth?: number;
    waitForResults?: boolean;
    windingness?: WindingnessLevel;
}

// @public
export type RoutePostRouteMatrixResponse = RouteMatrixResponse;

// @public
export interface RoutePostRouteMatrixSyncOptionalParams extends coreClient.OperationOptions {
    arriveAt?: Date;
    avoid?: RouteAvoidType[];
    computeTravelTimeFor?: ComputeTravelTimeFor;
    departAt?: Date;
    hilliness?: HillinessDegree;
    routeType?: RouteType;
    sectionType?: SectionType;
    traffic?: boolean;
    travelMode?: TravelMode;
    vehicleAxleWeight?: number;
    vehicleHeight?: number;
    vehicleLength?: number;
    vehicleLoadType?: VehicleLoadType;
    vehicleMaxSpeed?: number;
    vehicleWeight?: number;
    vehicleWidth?: number;
    waitForResults?: boolean;
    windingness?: WindingnessLevel;
}

// @public
export type RoutePostRouteMatrixSyncResponse = RouteMatrixResponse;

// @public
export interface RouteRange {
    readonly boundary?: CoordinatesPair[];
    center?: CoordinatesPair;
}

// @public
export type RouteRepresentation = string;

// @public
export interface RouteResponseReport {
    readonly effectiveSettings?: RouteResponseReportEffectiveSetting[];
}

// @public
export interface RouteResponseReportEffectiveSetting {
    readonly key?: string;
    readonly value?: string;
}

// @public
export interface RouteResultGuidance {
    readonly instructionGroups?: RouteResultInstructionGroup[];
    readonly instructions?: RouteResultInstruction[];
}

// @public
export interface RouteResultInstruction {
    readonly combinedMessage?: string;
    readonly countryCode?: string;
    readonly drivingSide?: DrivingSide;
    readonly exitNumber?: string;
    instructionType?: GuidanceInstructionType;
    readonly junctionType?: JunctionType;
    readonly maneuver?: GuidanceManeuver;
    readonly message?: string;
    point?: CoordinatesPair;
    readonly pointIndex?: number;
    readonly possibleCombineWithNext?: boolean;
    readonly roadNumbers?: string[];
    readonly roundaboutExitNumber?: string;
    readonly routeOffsetInMeters?: number;
    readonly signpostText?: string;
    readonly stateCode?: string;
    readonly street?: string;
    readonly travelTimeInSeconds?: number;
    readonly turnAngleInDecimalDegrees?: number;
}

// @public
export interface RouteResultInstructionGroup {
    readonly firstInstructionIndex?: number;
    readonly groupLengthInMeters?: number;
    readonly groupMessage?: string;
    readonly lastInstructionIndex?: number;
}

// @public (undocumented)
export interface RouteResultLeg {
    readonly points?: CoordinatesPair[];
    readonly summary?: RouteResultLegSummary;
}

// @public
export interface RouteResultLegSummary {
    readonly arrivalTime?: string;
    readonly batteryConsumptionInkWh?: number;
    readonly departureTime?: string;
    readonly fuelConsumptionInLiters?: number;
    readonly historicTrafficTravelTimeInSeconds?: number;
    readonly lengthInMeters?: number;
    readonly liveTrafficIncidentsTravelTimeInSeconds?: number;
    readonly noTrafficTravelTimeInSeconds?: number;
    readonly trafficDelayInSeconds?: number;
    readonly travelTimeInSeconds?: number;
}

// @public (undocumented)
export interface RouteResultSection {
    readonly delayInSeconds?: number;
    readonly effectiveSpeedInKmh?: number;
    readonly endPointIndex?: number;
    readonly magnitudeOfDelay?: MagnitudeOfDelay;
    readonly sectionType?: string;
    readonly simpleCategory?: string;
    readonly startPointIndex?: number;
    tec?: RouteResultSectionTec;
    readonly travelMode?: string;
}

// @public
export interface RouteResultSectionTec {
    causes?: RouteResultSectionTecCause[];
    readonly effectCode?: number;
}

// @public
export interface RouteResultSectionTecCause {
    readonly mainCauseCode?: number;
    readonly subCauseCode?: number;
}

// @public
export type RouteType = string;

// @public
export type SectionType = string;

// @public
export type TextFormat = string;

// @public
export type TravelMode = string;

// @public
export type VehicleEngineType = string;

// @public
export type VehicleLoadType = string;

// @public
export type WindingnessLevel = string;


// (No @packageDocumentation comment for this package)

```
